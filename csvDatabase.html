<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Database</title>
<style>
/**
 * Copyright 2025 gary
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     https://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* RESET STARTS */
html {
    box-sizing: border-box;
    font-size: 16px;
}

*,
*:before,
*:after {
    box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
    margin: 0;
    padding: 0;
    font-weight: normal;
}

ol,
ul {
    list-style: none;
}

img {
    max-width: 100%;
    height: auto;
}

/* RESET ENDS */


#middle-section {
    display: flex;
    flex-direction: row;
}

#left-side,
#right-side {
    flex: 1;
}

th,
td {
    border: 1px solid black;
    text-align: left;
}

#table-input-form {
    display: none;
}

#left-side {
    overflow-x: scroll;
}

.color-green {
    color: green;
}

.fixed-size-scroll {
    overflow-x: auto;
    max-height: 300px;
    overflow-y: auto;
    padding: 5px;
    border: 1px solid grey;
    margin-bottom: 10px;
}
/* makes last member in a span go all the way to the right */
#top-nav span{
    margin-left:auto;
}

#output {
    overflow-x: auto;
    max-height: 600px;
    overflow-y: auto;
    padding: 5px;
    border: 1px solid grey;
    margin-bottom: 10px;
}

#left-side,
#right-side {
    overflow-y: auto;
    /* max-height: 50vh; */
    height: 75vh;
}

#output>table {
    /* background-color: wheat; */
}

footer {
    position: fixed;
    bottom: 0;
    left: 50%;
    background-color: transparent;
    color: grey;
    text-align: center;
    transform: translate(-50%, 0%);
}

#top-section {
    display: flex;
    flex-direction: column;
}

nav {
    display: flex;
    flex-direction: row;
}

#top-section,
#middle-section,
#bottom-section #table-input-form,
#sqlInputTextarea-1,#sqlInputTextarea-2 {
    /* background-color: lightgoldenrodyellow; */
    border: 1px solid grey;
}

#table-input-form,
#right-side {
    display: flex;
    flex-direction: column;
    padding: 10px;
}

td,
th {
    max-width: 8rem;
    overflow-wrap: break-word;
}

table {
    border-collapse: collapse;
    width: 99%;
}

#left-side,
#right-side,
#bottom-section,
#top-section {
    padding: 10px;
}

h1 {
    padding: 10px;
    text-align: center;
}

#csv-input {
    height: 200px;
}

nav {
    padding: 10px;
}

nav>button {
    margin-right: 5px;
}

textarea {
    max-width: 100%;
}

#right-side {
    visibility: hidden;
}

.fixed-size-scroll,
textarea,
input[type="text"],
#output {
    border-radius: 5px;
    border-style: none;
    border: 1px solid grey;
}

html {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 16px;
}

textarea {
    font-family: 'Courier New', Courier, monospace;
    font-size: 14px;
}

/* COLORS */
table {
    /* background-color: wheat; */
    background-color: white;
}

tbody {

    background-color: white;
}

.fixed-size-scroll,
#output,
table,

h1 {
    border-radius: 5px;
    /* background-color: silver; */
    background-color: darkgrey;
}

html {
    background-color: whitesmoke;
}

#sqlInputTextarea-1,#sqlInputTextarea-2 {
    height: 60px;

}
#sqlInputTextarea-1,#sqlInputTextarea-2,#csvResult,#csv-input{
    max-width: 100%;
    min-width: 100%;
}

#popup {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px;

    background-color:whitesmoke;
    color: inherit;

    border: 1px solid grey;
    border-radius: 5px;
    z-index: 1000;
}

select{
    max-width: 100%;
}
/* SCATTER PLOT */
.canvas-container {
    border: 1px solid #000;
    width: 100%;
    height: 154px; /* Set a default height */
    width: 250px;
    max-width: 100%;
    resize: both; /* Allow resizing */
    overflow: auto; /* Allow scrolling if content overflows */
    position: relative; /* Position relative for absolute positioning of canvas */
    margin:5px;
}

canvas {
    display: block; /* Remove inline spacing */
    width: 100%; /* Make canvas responsive */
    height: 100%; /* Make canvas responsive */
}

.flex-row-vertical-center{
    display: flex;
    flex-direction: row;
    align-items: center;
}
.flex-column-horizontal-center{
    display: flex;
    flex-direction: column;
    align-items: center;
}
#y-axis-label{
    rotate: -90deg;
}
/* #plot-controls-nav{
    display: flex;
    flex-direction: column;


} */
.flex-column{
    display: flex;
    flex-direction: column;
}
.flex-row{
    display: flex;
    flex-direction: row;
}
.justify-content-center{
    justify-content: center;
}

#y-axis-labels-container{
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: end;
}
#x-axis-labels-container{
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    width: 60%;
}
</style>
</head>

<body>
    <header>
        <h1>CSV Database</h1>
    </header>
    <nav id="top-nav">
        <button id="loadDatabaseButton">Load Database</button>
        <button id="saveDatabaseButton">Save Database</button>
        <button id="add-table-button">Add Table</button>
        <span><button id="load-tradewinds">Load Sample DB</button><button id="load-SQLSamples">Load Sample
                SQL</button></span>
    </nav>
    <main>
        <div id="top-section">
            <div id="popup"></div>
            <label for="sqlOptionsSelect">SQL Cheat Sheet: </label><select id="sqlOptionsSelect"></select>
            <textarea id="sqlInputTextarea-1" placeholder="Put your ; separated SQL statments here." spellcheck="false"
                value=""></textarea>
            <nav> <button id="run-button-1">Run Query</button><button id="load-query-1">Load Query</button><button
                    id="save-query-1">Save Query</button></nav>
            <textarea id="sqlInputTextarea-2" placeholder="Put your ; separated SQL statments here." spellcheck="false"
                value=""></textarea>
            <nav> <button id="run-button-2">Run Query</button><button id="load-query-2">Load Query</button><button
                    id="save-query-2">Save Query</button></nav>

        </div>
        <div id="middle-section">
            <div id="left-side">
                Loaded tables will appear here.
            </div>
            <div id="right-side">
                <nav class="flex-row justify-content-center"><button class='saveTextByIDButton' id="csvResult-save">Save
                        Results</button><button class="copyTextByIDButton" id="csvResult-copy">Copy To
                        Clipboard</button>
                    <button id="scatter-plot-button">Scatter Plot</button>
                </nav>
                <div id="plot-container">
                    <div class="flex-column">
                        <div class="flex-row justify-content-center">
                            <div class="flex-column">
                                <label for="x-axis">X Axis:</label>
                                <select id="x-axis"></select>
                                <label for="y-axis">Y Axis:</label>
                                <select id="y-axis"></select>
                                <label for="y-axis">Label (Optional)</label>
                                <select id="label-select"></select>
                                
                            </div>

                            <div class="flex-column">
                                <label for="x-axis-min">X Min:</label>
                                <input id="x-axis-min" placeholder="Enter Auto or a number..." value="Auto">
                                <label for="x-axis-max">X Max:</label>
                                <input id="x-axis-max" placeholder="Enter Auto or a number..." value="Auto">
                            </div>
                            <div class="flex-column">
                                <label for="y-axis-min">Y Min:</label>
                                <input id="y-axis-min" placeholder="Enter Auto or a number..." value="Auto">
                                <label for="y-axis-max">Y Max:</label>
                                <input id="y-axis-max" placeholder="Enter Auto or a number..." value="Auto">
                                <label for="clicked-coordinates">Clicked Coordinates:</label>
                                <input id="clicked-coordinates" readonly placeholder="Click on graph to see coordinates...">

                            </div>
                        </div>
                        <span style="text-align: center;"><input type="checkbox" id="best-fit-checkbox"><label
                                for="best-fit-checkbox">Best Fit Line</label>
                    </div>
                    </nav>
                    <div>
                        <div class="flex-column-horizontal-center">
                            <div class="flex-row">
                                <div id="y-axis-labels-container">
                                    <label id="y-max-label">y max</label>
                                    <label id="y-axis-label">y label</label>
                                    <label id="y-min-label">y min</label>

                                </div>
                                <div id="canvasContainer" class="canvas-container">
                                    <canvas id="scatterPlot"></canvas>
                                </div>

                            </div>
                            <div id="x-axis-labels-container">
                                <label id="x-min-label">x-min</label>
                                <label id="x-axis-label">x lable</label>
                                <label id="x-max-label">x-max</label>
                            </div>
                        </div>
                    </div>
                </div>
                <textarea id="csvResult" rows="10" cols="30" placeholder="Query results will appear here..."
                    spellcheck="false"></textarea>
                <nav><button id="show-all-query">Show All Rows</button><span>Row Count: </span><span
                        id="row-count"></span></nav>
                <div id="right-side-results"></div>
            </div>
        </div>

        <div id="bottom-section">
            <div id="table-input-form">

                <label for="table-name">Table Title:</label>
                <input type="text" id="table-name" placeholder="Enter table title">
                <label for="csv-input">CSV Input:</label>
                <textarea id="csv-input" placeholder="Enter CSV data here" spellcheck="false"></textarea>
                <nav>
                    <button id="load-button">Load CSV</button>
                    <button id="convert-CSV-button">Convert/Refresh CSV</button>
                    <button id="save-table-button">Save to Database</button>
                    <button id="cancel-formsave-button">Cancel</button>
                </nav>
                <div id="output">
                </div>
            </div>
        </div>
    </main>
    <footer>&copy; Gary Davenport 2025</footer>
    <script>
        document.getElementById("plot-container").style.display = "none";
        document.getElementById("csvResult").style.display = "inherit";
        document.getElementById("scatter-plot-button").addEventListener("click", toggleScatterPlot);
        function toggleScatterPlot() {
            let plotContainer = document.getElementById("plot-container");
            let csvResultsContainer = document.getElementById("csvResult");
            if (plotContainer.style.display === "none") {
                plotContainer.style.display = "block";
                csvResultsContainer.style.display = "none";
            }
            else {
                plotContainer.style.display = "none";
                csvResultsContainer.style.display = "inherit";
            }
        }




    </script>
<script>
let plotDataset = [
    ['Age', 'Height', 'Weight', 'Income', 'Satisfaction'],
    [25, 150, 50, 30000, 3],
    [30, 160, 60, 40000, 4],
    [35, 170, 70, 50000, 5],
    [40, 180, 80, 60000, 2],
    [45, 190, 90, 70000, 4],
    [50, 200, 100, 80000, 5],
    [55, 155, 55, 35000, 3],
    [60, 165, 65, 45000, 4],
    [65, 175, 75, 55000, 2],
    [70, 185, 85, 65000, 5],
    [75, 195, 95, 75000, 4],
    [80, 205, 105, 85000, 3]
];

const xSelect = document.getElementById('x-axis');
const ySelect = document.getElementById('y-axis');
const labelSelect=document.getElementById('label-select');
const plotCanvas = document.getElementById('scatterPlot');
const plotCtx = plotCanvas.getContext('2d');
const bestFitCheckbox = document.getElementById('best-fit-checkbox');
let xMinInput=document.getElementById("x-axis-min");
let xMaxInput=document.getElementById("x-axis-max");
let yMinInput=document.getElementById("y-axis-min");
let yMaxInput=document.getElementById("y-axis-max");

let plotDatasetHeaders = plotDataset[0]; // Assuming the first row contains the plotDatasetHeaders

function populateSelectElementsOfPlotHeaders() {
    xSelect.innerHTML="";
    ySelect.innerHTML="";
    labelSelect.innerHTML="";
    document.getElementById("clicked-coordinates").value="";
    // Populate the X axis select element

    let labelOption = document.createElement('option');
    labelOption.value = "NONE";
    labelOption.textContent = "NONE";
    labelSelect.appendChild(labelOption);

    for (let i = 0; i < plotDatasetHeaders.length; i++) {
        const xOption = document.createElement('option');
        xOption.value = plotDatasetHeaders[i];
        xOption.textContent = plotDatasetHeaders[i];
        xSelect.appendChild(xOption);

        const yOption = document.createElement('option');
        yOption.value = plotDatasetHeaders[i];
        yOption.textContent = plotDatasetHeaders[i];
        ySelect.appendChild(yOption);

        const labelOption = document.createElement('option');
        labelOption.value = plotDatasetHeaders[i];
        labelOption.textContent = plotDatasetHeaders[i];
        labelSelect.appendChild(labelOption);

    }

    // Populate the Y axis select element
    // for (let i = 0; i < plotDatasetHeaders.length; i++) {
    //     const yOption = document.createElement('option');
    //     yOption.value = plotDatasetHeaders[i];
    //     yOption.textContent = plotDatasetHeaders[i];
    //     ySelect.appendChild(yOption);
    // }
    
    xMinInput.value="Auto";
    xMaxInput.value="Auto";
    yMinInput.value="Auto";
    yMaxInput.value="Auto";
}


// Function to draw the scatter plot
function drawScatterPlot() {
    let xHeader = xSelect.value;
    let yHeader = ySelect.value;
    let labelHeader = labelSelect.value; // Use .value to get the selected label

    let xIndex = plotDatasetHeaders.indexOf(xHeader);
    let yIndex = plotDatasetHeaders.indexOf(yHeader);
    let labelIndex = plotDatasetHeaders.indexOf(labelHeader); // Get the index of the selected label

    let xValues = [];
    let yValues = [];
    let labels = []; // Array to hold the labels
    
    // Populate xValues, yValues, and labels using for loops
    for (let i = 1; i < plotDataset.length; i++) {
        xValues.push(Number(plotDataset[i][xIndex]));
        yValues.push(Number(plotDataset[i][yIndex]));
        labels.push(plotDataset[i][labelIndex]); // Get the label for each point
    }

    // Get max/min values for plot
    let xMin = Math.min(...xValues);
    let xMax = Math.max(...xValues);
    let yMin = Math.min(...yValues);
    let yMax = Math.max(...yValues);

    // Check for user-defined min/max values
    if (xMinInput.value.trim() !== "") {
        let result = Number(xMinInput.value.trim());
        if (!isNaN(result)) {
            xMin = result;
        }
    }

    if (xMaxInput.value.trim() !== "") {
        let result = Number(xMaxInput.value.trim());
        if (!isNaN(result)) {
            xMax = result;
        }
    }

    if (yMinInput.value.trim() !== "") {
        let result = Number(yMinInput.value.trim());
        if (!isNaN(result)) {
            yMin = result;
        }
    }

    if (yMaxInput.value.trim() !== "") {
        let result = Number(yMaxInput.value.trim());
        if (!isNaN(result)) {
            yMax = result;
        }
    }

    // Resize plotCanvas to fit the container
    plotCanvas.width = plotCanvas.clientWidth;
    plotCanvas.height = plotCanvas.clientHeight;

    plotCtx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);

    // Draw points and labels using for loop
    const pointSize = 3; // Fixed point size
    for (let i = 0; i < xValues.length; i++) {
        let x = xValues[i];
        let y = yValues[i];
        let xPos = ((x - xMin) / (xMax - xMin)) * plotCanvas.width;
        let yPos = plotCanvas.height - ((y - yMin) / (yMax - yMin)) * plotCanvas.height;

        // Draw the point
        plotCtx.beginPath();
        plotCtx.arc(xPos, yPos, pointSize, 0, Math.PI * 2); // Use fixed point size
        plotCtx.fillStyle = 'grey';
        plotCtx.fill();

        // Draw the label next to the point
        if (labelHeader!=="NONE"){
            plotCtx.fillStyle = 'black'; // Set label color
            plotCtx.font = '10px Arial'; // Set font size and family
            plotCtx.fillText(labels[i], xPos + 5, yPos); // Draw label slightly to the right of the point
        }

    }

    // Draw best fit line if checkbox is checked
    if (bestFitCheckbox.checked) {
        drawBestFitLine(xValues, yValues, xMin, xMax, yMin, yMax);
    }
    
    // Define the click event handler with access to xMin, xMax, yMin, and yMax
    const handleCanvasClick = (function(xMin, xMax, yMin, yMax) {
        return function(event) {
            const rect = plotCanvas.getBoundingClientRect();
            const xClick = event.clientX - rect.left; // Get x position relative to canvas
            const yClick = event.clientY - rect.top;  // Get y position relative to canvas

            // Convert click coordinates back to data values
            const xValue = xMin + (xClick / plotCanvas.width) * (xMax - xMin);
            const yValue = yMax - (yClick / plotCanvas.height) * (yMax - yMin);

            // Log the coordinates
            console.log(`Clicked coordinates: X = ${xValue}, Y = ${yValue}`);
            
            // Optionally, you can display the coordinates on the page
            document.getElementById("clicked-coordinates").value = `X = ${xValue.toFixed(2)}, Y = ${yValue.toFixed(2)}`;
        };
    })(xMin, xMax, yMin, yMax); // Immediately invoke the function with the current values

    // Remove existing click event listener if it exists
    plotCanvas.removeEventListener('click', handleCanvasClick);

    // Add click event listener to the canvas
    plotCanvas.addEventListener('click', handleCanvasClick);


    // Update axis labels and min/max labels
    document.getElementById("x-axis-label").innerHTML = xHeader;
    document.getElementById("y-axis-label").innerHTML = yHeader;
    document.getElementById("x-min-label").innerHTML = "Min: " + xMin.toString();
    document.getElementById("x-max-label").innerHTML = "Max: " + xMax.toString();
    document.getElementById("y-min-label").innerHTML = "Min: " + yMin.toString();
    document.getElementById("y-max-label").innerHTML = "Max: " + yMax.toString();
}

function drawBestFitLine(xValues, yValues, xMin, xMax, yMin, yMax) {
    let n = xValues.length;
    let xMean = 0;
    let yMean = 0;

    // Calculate means using for loop
    for (let i = 0; i < n; i++) {
        xMean += xValues[i];
        yMean += yValues[i];
    }
    xMean /= n;
    yMean /= n;

    let numerator = 0;
    let denominator = 0;

    // Calculate numerator and denominator for slope using for loop
    for (let i = 0; i < n; i++) {
        numerator += (xValues[i] - xMean) * (yValues[i] - yMean);
        denominator += (xValues[i] - xMean) ** 2;
    }

    let slope = numerator / denominator;
    let intercept = yMean - slope * xMean;

    let xStart = xMin;
    let xEnd = xMax;
    let yStart = slope * xStart + intercept;
    let yEnd = slope * xEnd + intercept;

    let xStartPos = ((xStart - xMin) / (xMax - xMin)) * plotCanvas.width;
    let yStartPos = plotCanvas.height - ((yStart - yMin) / (yMax - yMin)) * plotCanvas.height;
    let xEndPos = ((xEnd - xMin) / (xMax - xMin)) * plotCanvas.width;
    let yEndPos = plotCanvas.height - ((yEnd - yMin) / (yMax - yMin)) * plotCanvas.height;

    plotCtx.beginPath();
    plotCtx.moveTo(xStartPos, yStartPos);
    plotCtx.lineTo(xEndPos, yEndPos);
    plotCtx.strokeStyle = 'red';
    plotCtx.lineWidth = 2; // Fixed line width
    plotCtx.stroke();

    // Calculate R-squared
    let ssTotal = 0; // Total sum of squares
    let ssResidual = 0; // Residual sum of squares

    for (let i = 0; i < n; i++) {
        let yPredicted = slope * xValues[i] + intercept;
        ssTotal += (yValues[i] - yMean) ** 2; // SST
        ssResidual += (yValues[i] - yPredicted) ** 2; // SSR
    }

    let rSquared = 1 - (ssResidual / ssTotal);

    // Display the equation and R-squared value
    plotCtx.fillStyle = 'red';
    plotCtx.font = '12px Arial';
    plotCtx.fillText('y = ' + slope.toFixed(2) + 'x + ' + intercept.toFixed(2), 10, 20);
    plotCtx.fillText('RÂ² = ' + rSquared.toFixed(2), 10, 40); // Display R-squared value
}




// Event listeners for select changes and checkbox
xSelect.addEventListener('change', drawScatterPlot);
ySelect.addEventListener('change', drawScatterPlot);
labelSelect.addEventListener('change',drawScatterPlot);
xMinInput.addEventListener('change', drawScatterPlot);
xMaxInput.addEventListener('change', drawScatterPlot);
yMinInput.addEventListener('change', drawScatterPlot);
yMaxInput.addEventListener('change', drawScatterPlot);
bestFitCheckbox.addEventListener('change', drawScatterPlot);

// window.addEventListener('resize', drawScatterPlot);
// function debounce(func, wait) {
//     let timeout;
//     return function executedFunction(...args) {
//         const later = () => {
//             clearTimeout(timeout);
//             func(...args);
//         };
//         clearTimeout(timeout);
//         timeout = setTimeout(later, wait);
//     };
// }

// // Use debounce for the resize event
// window.addEventListener('resize', debounce(function() {
//     drawScatterPlot();
// }, 200)); // Adjust the wait time as needed
// Use ResizeObserver to detect changes to the canvas size
const resizeObserver = new ResizeObserver(() => {
    drawScatterPlot();
});

// Observe the canvas element
resizeObserver.observe(plotCanvas);

populateSelectElementsOfPlotHeaders();

// Initial draw
drawScatterPlot();

</script>
<script>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                                                                //
// FUNCTION NAME                                       				INPUT                                           OUTPUT                                        //
// csvToArrays(csvString)                              				csv                                             array of arrays                               //
// arraysToCSV(arrayOfArrays,newLineString="\n")       				array of arrays, "\n" or "\r\n"                 csv                                           //
// arraysToJSON(arrays, usingHeaders)                  				array of arrays                                 JSON {["headers"]=[],["data"]=[{},{},{}...]}  //
// JSONToArrays(jsonObject, includeHeaders)            				JSON {["headers"]=[],["data"]=[{},{},{}...]}    array of arrays                               //
// unorderdJSONToArrays(jsonObject,includeHeaders)     				JSON [{"key":"value"},{k:v},...]                array of arrays                               //
//                                                                                                                                                                //
// COMPOSITE FUNCTIONS:                                                                                                                                           //
// csvToJSON(csvString, usingHeaders)                  				csv                                             JSON {["headers"]=[],["data"]=[{},{},{}...]}  //                                        
// JSONToCSV(jsonObject, includeHeaders=true,newLineString="\n")	JSON {["headers"]=[],["data"]=[{},{},{}...]}    csv                                           //
// unorderedJSONToCSV(jsonObject, includeHeaders)      				JSON [{"key":"value"},{k:v},...]                csv                                           //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function _replaceReallCommmasInCSV(contents, commaReplacement) {

    //temp fix
    //contents=contents.split("\r\n").join("\n");
    //temp fix
    let newContents = "";
    let inside = -1;
    for (let i = 0; i < contents.length; i++) {
        let thisChar = contents.charAt(i);
        if (thisChar === '"') {
            inside = inside * -1;
            newContents += thisChar;
        }
        else if (thisChar === ",") {
            if (inside === -1) {//comma is outside of quotes, replace
                newContents += commaReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        // else if (thisChar === "\n") {
        //     if (inside === -1) {//\n is outside of quotes, replace
        //         newContents += newlineReplacement;
        //     }
        //     else {//comma is inside of quotes, don't replace
        //         newContents += thisChar;
        //     }
        // }
        else {
            newContents += thisChar;
        }
    }
    return (newContents);
}

function _replaceRealNewlinesInCSV(contents, newLineReplacement) {
    //temp fix
    //contents=contents.split("\r\n").join("\n");
    //temp fix
    let newContents = "";
    let inside = -1;
    for (let i = 0; i < contents.length; i++) {
        let thisChar = contents.charAt(i);
        if (thisChar === '"') {
            inside = inside * -1;
            newContents += thisChar;
        }
        // else if (thisChar === ",") {
        //     if (inside === -1) {//comma is outside of quotes, replace
        //         newContents += commaReplacement;
        //     }
        //     else {//comma is inside of quotes, don't replace
        //         newContents += thisChar;
        //     }
        // }
        else if (thisChar === "\n") {
            if (inside === -1) {//\n is outside of quotes, replace
                newContents += newLineReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        else {
            newContents += thisChar;
        }
    }
    return (newContents);
}



function _replaceRealCommasAndRealNewlinesInCSV(contents, commaReplacement, newlineReplacement) {
    //temp fix
    //contents=contents.split("\r\n").join("\n");
    //temp fix
    let newContents = "";
    let inside = -1;
    for (let i = 0; i < contents.length; i++) {
        let thisChar = contents.charAt(i);
        if (thisChar === '"') {
            inside = inside * -1;
            newContents += thisChar;
        }
        else if (thisChar === ",") {
            if (inside === -1) {//comma is outside of quotes, replace
                newContents += commaReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        else if (thisChar === "\n") {
            if (inside === -1) {//\n is outside of quotes, replace
                newContents += newlineReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        else {
            newContents += thisChar;
        }
    }
    //new added this will replace the "\r\n" with "\n", some programs
    //use the \r\n (ms outlook for example) instead of \n
    //newContents=JSON.stringify(newContents);
    //newContents.split("\"\r"+newlineReplacement).join(newlineReplacement);
    //newContents=JSON.parse(newContents);
    return (newContents);
}


function tokenMaker(intSize) {
    let token = "";
    let specialString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    for (let i = 0; i < intSize; i++) {
        token += specialString[Math.floor(Math.random() * specialString.length)];
    }
    //console.log(token);
    return token;
}

//Works with earlier versions of NodeJS and anywhere replaceAll not available
//from: https://stackoverflow.com/questions/62825358/javascript-replaceall-is-not-a-function-type-error
//author: https://stackoverflow.com/users/9513184/unmitigated
//Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
function myReplaceAll(str, match, replacement) {
    return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);
}


function getTokenNotInString(myString, intSize = 16) {
    let token = tokenMaker(16);
    while (myString.indexOf(token) !== -1) {
        token = tokenMaker(16);
    }
    return token;
}
function csvToArrays(CSVString) {
    // CSVString.split("\r\n").join("\n");
    // CSVString.split("\r\n").join("\n");
    //CSVString = myReplaceAll(CSVString,"\r\n", "\n");

    CSVString=CSVString.trim();

    let carriageReturnToken = getTokenNotInString(CSVString);
    CSVString = CSVString.split("\r").join(carriageReturnToken);
    CSVString = CSVString.split(carriageReturnToken + "\n").join("\n");

    let myArray = []; //initialization
    CSVString = CSVString.trim();

    let commaToken = getTokenNotInString(CSVString);

    CSVString = _replaceReallCommmasInCSV(CSVString, commaToken);

    let newlineToken = getTokenNotInString(CSVString);
    //find a string that is not present in CSV for using as temporary tag
    //while (CSVString.indexOf(newlineToken) !== -1) {
    //    newlineToken = tokenMaker(16);
    //}

    CSVString = _replaceRealNewlinesInCSV(CSVString, newlineToken);
    /////////////REALLY should be doing one string replacement at a time, not 2

    //CSVString = _replaceRealCommasAndRealNewlinesInCSV(CSVString, commaToken, newlineToken);

    let lines = CSVString.split(newlineToken);

    for (let i = 0; i < lines.length; i++) {
        //an array of cells from row in csv line
        //it contains the quotes and is formatted with double quotes
        let rowArray = lines[i].split(commaToken);
        for (let j = 0; j < rowArray.length; j++) {

            //remove outer quotes if present
            if (rowArray[j][rowArray[j].length - 1] === '"') {
                rowArray[j] = rowArray[j].slice(0, rowArray[j].length - 1);
            }
            if (rowArray[j][0] === '"') {
                rowArray[j] = rowArray[j].slice(1, rowArray[j].length);
            }
            //replace double inner quotes with singles
            rowArray[j] = rowArray[j].split('""').join('"');
        }
        myArray.push(rowArray);
    }
    return myArray;
}

function doesCellNeedQouted(str){
    
    // console.log("doesCellNeedQuoted:",str);
    // //see if it contains commas
    // console.log(",:",str.indexOf(',')!==-1)
    str=str.toString();
    if (str.indexOf(',')!==-1){
        return true;
    }
    //see if it contains double quotes
    else if (str.indexOf('"')!==-1){

        // console.log("\":",str.indexOf('"')!==-1);
        return true;
    }
    //see if contains newlines
    else if (str.indexOf("\n")!==-1){
        // console.log(("\\n:",str.indexOf("\n")!==-1));
        return true;
    }
    else{
        return false;
    }

}

function arraysToCSV(arrayOfArrays, newLineString = "\n") {
    // console.log(arrayOfArrays);
    let CSVString = "";
    //go through each 'line'
    for (let i = 0; i < arrayOfArrays.length; i++) {
        //go through each csv cell and build line

        for (let j = 0; j < arrayOfArrays[i].length; j++) {
            // console.log(i,arrayOfArrays.length);
            // console.log(arrayOfArrays[i]);
            // console.log(arrayOfArrays[i][j]);
            if (doesCellNeedQouted(arrayOfArrays[i][j])){
                CSVString += '"';
            }

            CSVString += arrayOfArrays[i][j].split('"').join('""');
            if (doesCellNeedQouted(arrayOfArrays[i][j])){
                CSVString += '",';
            }
            else{
                CSVString += ',';
            }

        }
        CSVString = CSVString.slice(0, -1) + newLineString; //takes off last comma and adds new line
    }
    CSVString = CSVString.slice(0, -(newLineString.length)); //takes off last \n character
    return CSVString;
}

function arraysToJSON(arrayOfArrays, usingHeaders = true) {
    let headers = [];
    let data = [];
    let table = {};
    if (usingHeaders === true) {                                //read in headers
        for (let i = 0; i < arrayOfArrays[0].length; i++) {
            let header = arrayOfArrays[0][i];
            let index = 0;
            while (headers.includes(header)) {                  //prevents duplicates
                console.log("WARNING - Duplicate header found: " + header);
                index += 1;
                header = header + index.toString();
                console.log("Attempting rename to: " + header);
            }
            headers.push(header);
        }
    } else {
        for (let i = 0; i < arrayOfArrays[0].length; i++) {     //make headers
            headers.push("header" + i.toString());
        }
    }
    if (usingHeaders === true) {
        startRow = 1;
    }
    else {
        startRow = 0;
    }
    for (let i = startRow; i < arrayOfArrays.length; i++) {//go throught every line
        let tempRow = {};
        for (let j = 0; j < headers.length; j++) {
            tempRow[headers[j]] = arrayOfArrays[i][j];
        }
        // console.log(tempRow);
        data.push(tempRow);
    }
    table["headers"] = headers;
    table["data"] = data;
    // console.log(JSON.stringify(table))
    return (table);
}

function JSONToArrays(jsonObject, includeHeaders = true) {
    let headers = jsonObject["headers"];
    let data = jsonObject["data"];
    let arrayOfArrays = [];
    if (includeHeaders === true) {
        let row = [];
        for (let i = 0; i < headers.length; i++) {
            row.push(headers[i].toString());
        }
        arrayOfArrays.push(row);
    }
    for (i = 0; i < data.length; i++) {
        let row = [];
        for (let j = 0; j < headers.length; j++) {
            if (data[i][headers[j]] === undefined) {
                row.push("");
            }
            else {
                row.push(data[i][headers[j]].toString());
            }
        }
        arrayOfArrays.push(row);
    }
    return (arrayOfArrays);
}

function unorderedJSONToArrays(jsonObject, includeHeaders = true) {
    //takes an array of objects [{},{},{}] where objects have key/value pairs
    let newObject = {};
    newObject["data"] = jsonObject;
    let headers = [];
    for (rowObject of jsonObject) { //rows of objects
        for (const key in rowObject) {
            if (!headers.includes(key)) {
                headers.push(key.toString());
            };
        }
    }
    newObject["headers"] = headers;
    return JSONToArrays(newObject, includeHeaders);
}

//COMPOSITE FUNCTIONS
function csvToJSON(csvString, usingHeaders = true) {
    let arrays = csvToArrays(csvString);
    let jsonObject = arraysToJSON(arrays, usingHeaders);
    return jsonObject;
}

function JSONToCSV(jsonObject, includeHeaders = true, newLineString = "\n") {
    let arrays = JSONToArrays(jsonObject, includeHeaders);
    let csvString = arraysToCSV(arrays, newLineString);
    return csvString;
}

function unorderedJSONToCSV(jsonObject, includeHeaders = true) {
    let arrays = unorderedJSONToArrays(jsonObject, includeHeaders);
    let csvString = arraysToCSV(arrays);
    return csvString;
}
</script>
<script>
//table format


// table={};
// table["name"]="myname";
// table["headers"]=[];
// table["data"]=[];
// table["dataTypes"]=[];//dataTypes can be "STRING" or "NUMBER"
// let database={};
// database["tables"]={};
// database["tables"]["myname"]=table;





function createTable(tableName, columns, dataTypes) {
    console.log("createTable(tableName, columns, dataTypes)", tableName, columns, dataTypes);
    //CREATE TABLE table_name (column1 datatype, column2 datatype, column3 datatype...);
    //tableName is a string
    //columns and dataTypes are index matched arrays;
    let thisTable = {};
    thisTable["name"] = tableName;
    thisTable["headers"] = columns;
    thisTable["data"] = [];
    thisTable["dataTypes"] = dataTypes;
    return (JSON.parse(JSON.stringify(thisTable)));
}

function alterTableAddColumn(table, columnName, dataType) {
    //ALTER TABLE table_name ADD column_name datatype; 
    let thisTable = JSON.parse(JSON.stringify(table));
    thisTable["headers"].push(columnName);
    thisTable["dataTypes"].push(dataType);
    //add empty cell for each row
    for (let i = 0; i < thisTable["data"].length; i++) {
        thisTable["data"][i].push("");
    }
    return (thisTable);
}

function alterTableChange(table, oldName, newName, dataType) {
    //ALTER TABLE table_name CHANGE samename samename newdatatype;  
    let thisTable = JSON.parse(JSON.stringify(table));
    let headerIndex = _getColumnIndex(oldName, thisTable["headers"]);
    console.log(headerIndex);
    thisTable["headers"][headerIndex] = newName;
    thisTable["dataTypes"][headerIndex] = dataType;
    return thisTable;
}

function _getColumnIndex(columnName, headers) {
    let index = headers.indexOf(columnName);
    // console.log(columnName,headers,index);
    return index;
}

function alterTableDropColumn(table, column) {
    //ALTER TABLE table_name DROP COLUMN column_name;
    let thisTable = JSON.parse(JSON.stringify(table));
    console.log("-" + column + "-", thisTable["headers"]);
    let index = _getColumnIndex(column, thisTable["headers"]);
    for (let i = 0; i < thisTable["data"].length; i++) {
        thisTable["data"][i].splice(index, 1);
        //remove that column
    }
    //remove that column from headers
    thisTable["headers"].splice(index, 1);
    //remove that column from datatypes
    thisTable["dataTypes"].splice(index, 1);
    return thisTable;
}

function deleteFromTableWhere(table, field, comparator, testValue) {
    //DELETE FROM table_name WHERE condition;
    let thisTable = JSON.parse(JSON.stringify(table));

    let data = thisTable["data"];
    //get dataType
    let index = _getColumnIndex(field, thisTable["headers"]);
    let whereDataType = thisTable["dataTypes"][index];
    //loop through data backwards and remove if where condition is positive
    for (let i = data.length - 1; i >= 0; i--) {
        //test where condition
        let row = data[i];
        let thisFieldValue = row[index];
        if (_testWhereCondition(thisFieldValue, comparator, testValue, whereDataType)) {
            data.splice(i, 1);
        }
    }
    return thisTable;
}
function describeTable(table) {
    //DESCRIBE pets;
    let tableToDescribe = JSON.parse(JSON.stringify(table));
    console.log("describeTable called");
    let thisTable = {};
    thisTable["name"] = "DESCRIBE " + tableToDescribe["name"];
    thisTable["headers"] = ["field", "dataType"];
    thisTable["dataTypes"] = []
    thisTable["dataTypes"].push("STRING");
    thisTable["dataTypes"].push("STRING");
    let data = thisTable["data"] = [];
    for (let i = 0; i < tableToDescribe["headers"].length; i++) {
        let row = [];
        row.push(tableToDescribe["headers"][i]);
        row.push(tableToDescribe["dataTypes"][i]);
        data.push(row)
    }
    return thisTable;
}

function insertInto(table, columns, values) {
    console.log(table, columns, values);
    //INSERT INTO thisTable_name (column1, column2, column3, ...) VALUES (`value1`, `value2`, `value3`, ...);
    let thisTable = JSON.parse(JSON.stringify(table));
    let headers = thisTable["headers"];
    //make a blank row
    let row = [];
    for (let i = 0; i < headers.length; i++) {
        row.push("");
    }
    //update values for the columns
    for (let i = 0; i < columns.length; i++) {
        let index = _getColumnIndex(columns[i], headers);
        console.log(index);

        row[index] = values[i];
    }
    //console.log(thisTable);
    thisTable["data"].push(row);
    // console.log(thisTable);
    return thisTable;
}
function renameTable(table, newName) {
    //RENAME TABLE old_table TO new_table;
    // console.log("processing renameTable");
    let thisTable = JSON.parse(JSON.stringify(table));
    // console.log(thisTable);
    thisTable["name"] = newName;
    // console.log("newname","-"+newName+"-");
    // console.log(thisTable);
    return thisTable;
}


function selectAll(table) {
    console.log("running selectAll(table)");
    //SELECT * FROM table_name;
    let thisTable = JSON.parse(JSON.stringify(table));
    thisTable["name"] = "result";
    return thisTable;
}


function selectLeftJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator) {
    console.log("!!!!!!!!!!!!!!!!!!!!!!!columns: ", columns);
    //    return process.selectLeftJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator);
    let resultTable = selectAllLeftJoin(leftTable, rightTable, leftColumn, rightColumn, comparator);
    resultTable = selectColumnsFromTable(resultTable, columns);
    return resultTable;

}

function selectRightJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator) {
    //    return process.selectLeftJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator);
    let resultTable = selectAllRightJoin(leftTable, rightTable, leftColumn, rightColumn, comparator);
    resultTable = selectColumnsFromTable(resultTable, columns);
    return resultTable;

}

function selectFullJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator) {
    //    return process.selectLeftJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator);
    let leftResultTable = selectAllLeftJoin(leftTable, rightTable, leftColumn, rightColumn, comparator);
    leftResultTable = selectColumnsFromTable(leftResultTable, columns);
    let rightResultTable = selectAllRightJoin(leftTable, rightTable, leftColumn, rightColumn, comparator);
    rightResultTable = selectColumnsFromTable(leftResultTable, columns);
    let resultTable = selectColumnsUnionAll(leftResultTable, columns, rightResultTable, columns);

    return resultTable;

}
selectColumnsUnionAll;

// function selectAllLeftJoin(leftTable, rightTable, leftColumn, rightColumn) {
//     leftTable=_convertTableToFormalColumns(leftTable);
//     rightTable=_convertTableToFormalColumns(rightTable);
//     leftArray=leftTable["data"];
//     rightArray=rightTable["data"];
//     leftKey=leftColumn;
//     rightKey=rightColumn;

//     const result = [];

//     for (let i = 0; i < leftArray.length; i++) {
//         const leftRow = leftArray[i];
//         let foundMatch = false;
//         const newRow = [...leftRow];

//         for (let j = 0; j < rightArray.length; j++) {
//             const rightRow = rightArray[j];

//             if (leftRow[leftKey] === rightRow[rightKey]) {
//                 newRow.push(...rightRow);
//                 foundMatch = true;
//                 break;
//             }
//         }

//         if (!foundMatch) {
//             newRow.push(null);
//         }

//         result.push(newRow);
//     }
//     console.log(JSON.stringify(result));
//     let resultTable={};
//     resultTable["name"]="result";
//     resultTable["data"]=result;
//     resultTable["headers"]=leftTable["headers"].concat(rightTable["headers"]);
//     resultTable["dataTypes"]=leftTable["dataTypes"].concat(rightTable["dataTypes"]);
//     console.log("RESULT LENGTH",result.length);
//     console.log("result",result);
//     console.log("RESULT TABLE",resultTable);
//     return resultTable;
// }

function selectAllRightJoin(leftTable, rightTable, leftColumn, rightColumn, comparator) {
    leftColumn = leftColumn.trim();
    rightColumn = rightColumn.trim();

    let lTable = JSON.parse(JSON.stringify(leftTable));
    lTable = _convertTableToFormalColumns(lTable);

    let rTable = JSON.parse(JSON.stringify(rightTable));
    rTable = _convertTableToFormalColumns(rTable);

    let leftIndex = _getColumnIndex(leftColumn, lTable["headers"]);
    console.log("ltable!!!!!!!!!!!!", lTable);
    console.log("rTable", rTable);

    let rightIndex = _getColumnIndex(rightColumn, rTable["headers"]);
    let dataType = rTable["dataTypes"][rightIndex];

    let leftData = lTable["data"];
    let rightData = rTable["data"];

    let leftHeaders = lTable["headers"];
    let rightHeaders = rTable["headers"];

    let headers = leftHeaders.concat(rightHeaders);
    let dataTypes = lTable["dataTypes"].concat(rightTable["dataTypes"]);

    let resultData = [];
    //go through the left table rows
    for (let i = 0; i < rightData.length; i++) {
        //go through the right table rows
        let matchFound = false;
        for (let j = 0; j < leftData.length; j++) {
            if (_testWhereCondition(leftData[j][leftIndex], comparator, rightData[i][rightIndex], dataType)) {
                matchFound = true;
                let row = leftData[j].concat(rightData[i]);
                resultData.push(row);
            }
        }
        if (matchFound === false) {
            let row = [];
            for (let j = 0; j < leftHeaders.length; j++) {
                row.push("");
            }
            row = row.concat(rightData[i]);

            resultData.push(row);
        }
    }

    let resultTable = {}
    resultTable["headers"] = headers;
    resultTable["data"] = resultData;
    resultTable["name"] = "result";
    resultTable["dataTypes"] = dataTypes;
    console.log("SHOULD BE ALL HEADERS", resultTable);

    return resultTable;
}

function selectAllLeftJoin(leftTable, rightTable, leftColumn, rightColumn, comparator) {
    leftColumn = leftColumn.trim();
    rightColumn = rightColumn.trim();

    let lTable = JSON.parse(JSON.stringify(leftTable));
    lTable = _convertTableToFormalColumns(lTable);

    let rTable = JSON.parse(JSON.stringify(rightTable));
    rTable = _convertTableToFormalColumns(rTable);

    let leftIndex = _getColumnIndex(leftColumn, lTable["headers"]);
    let dataType = lTable["dataTypes"][leftIndex];

    let rightIndex = _getColumnIndex(rightColumn, rTable["headers"]);

    let leftData = lTable["data"];
    let rightData = rTable["data"];

    let leftHeaders = lTable["headers"];
    let rightHeaders = rTable["headers"];

    let headers = leftHeaders.concat(rightHeaders);
    let dataTypes = lTable["dataTypes"].concat(rightTable["dataTypes"]);

    let resultData = [];
    //go through the left table rows
    for (let i = 0; i < leftData.length; i++) {
        //go through the right table rows
        let matchFound = false;
        for (let j = 0; j < rightData.length; j++) {
            if (_testWhereCondition(leftData[i][leftIndex], comparator, rightData[j][rightIndex], dataType)) {
                matchFound = true;
                let row = leftData[i].concat(rightData[j]);
                resultData.push(row);
            }
        }
        if (matchFound === false) {
            let row = leftData[i];
            for (let j = 0; j < rightHeaders.length; j++) {
                row.push("");
            }
            resultData.push(row);
        }
    }

    let resultTable = {}
    resultTable["headers"] = headers;
    resultTable["data"] = resultData;
    resultTable["name"] = "result";
    resultTable["dataTypes"] = dataTypes;

    return resultTable;
}


function selectAllInnerJoin(leftTable, rightTable, leftColumn, rightColumn, comparator) {
    leftColumn = leftColumn.trim();
    rightColumn = rightColumn.trim();

    let lTable = JSON.parse(JSON.stringify(leftTable));
    lTable = _convertTableToFormalColumns(lTable);

    let rTable = JSON.parse(JSON.stringify(rightTable));
    rTable = _convertTableToFormalColumns(rTable);

    // console.log('leftColumn, lTable["headers"]');
    // console.log(leftColumn, lTable["headers"]);

    let leftIndex = _getColumnIndex(leftColumn, lTable["headers"]);
    // console.log("leftIndex",leftIndex);
    let dataType = lTable["dataTypes"][leftIndex];

    let rightIndex = _getColumnIndex(rightColumn, rTable["headers"]);

    let leftData = lTable["data"];
    let rightData = rTable["data"];

    let leftHeaders = lTable["headers"];
    let rightHeaders = rTable["headers"];

    let headers = leftHeaders.concat(rightHeaders);
    let dataTypes = lTable["dataTypes"].concat(rightTable["dataTypes"]);

    let resultData = [];
    //go through the left table rows
    for (let i = 0; i < leftData.length; i++) {
        console.log("joining on row: ", i);
        //go through the right table rows
        for (let j = 0; j < rightData.length; j++) {
            // console.log("leftData[i][leftIndex], comparator, rightData[j][rightIndex], dataType");
            // console.log(leftData[i][leftIndex], comparator, rightData[j][rightIndex], dataType);
            if (_testWhereCondition(leftData[i][leftIndex], comparator, rightData[j][rightIndex], dataType)) {
                let row = leftData[i].concat(rightData[j]);
                resultData.push(row);
            }
        }
    }

    let resultTable = {}
    resultTable["headers"] = headers;
    resultTable["data"] = resultData;
    resultTable["name"] = "result";
    resultTable["dataTypes"] = dataTypes;

    return resultTable;
}

function selectAllCrossJoin(leftTable, rightTable) {
    //convert to formal tables; also hard copies
    let lTable = _convertTableToFormalColumns(leftTable);
    let rTable = _convertTableToFormalColumns(rightTable);
    let resultTable = {};
    resultTable["name"] = "result";
    //concat headers;
    resultTable["headers"] = lTable["headers"].concat(rTable["headers"]);
    resultTable["dataTypes"] = lTable["dataTypes"].concat(rTable["dataTypes"]);
    let resultData = [];
    for (let i = 0; i < lTable["data"].length; i++) {//no error checking on equal lengths
        resultData = lTable["data"][i].concat(rTable["data"][i]);
    }
    resultTable["data"] = resultData;
    return resultTable;
}
function selectAllConcatCompositeKey(table, keyName, columns, tokenIsAField) {
    //SELECT *, CONCAT(Site, " - ", Year, " - ", Month) AS compositeKey FROM myTable;
    let resultTable = JSON.parse(JSON.stringify(table));
    let data = resultTable["data"];
    resultTable["name"] = "result";
    resultTable["headers"].push(keyName);
    resultTable["dataTypes"].push("STRING");
    //loop through data and make composite key
    let newData = [];
    for (let i = 0; i < data.length; i++) {
        let newToken = "";
        //make new composite key
        for (let j = 0; j < columns.length; j++) {
            if (tokenIsAField[j]) {
                //get value of that field
                let index = _getColumnIndex(columns[j], resultTable["headers"]);
                newToken += data[i][index].toString();
            }
            else {
                newToken += columns[j].toString();
            }
        }
        data[i].push(newToken);
    }
    resultTable["data"] = data;//probably not needed;
    return resultTable;
}
function selectAllOrderBy(table, sortField, direction) {
    //SELECT * FROM Products ORDER BY Price ASC

}
function selectAllWhere(table, field, comparator, testValue) {



    //SELECT * FROM table_name WHERE condition;
    let thisTable = JSON.parse(JSON.stringify(table));
    let data = thisTable["data"];
    let headers = thisTable["headers"];
    let fieldIndex = _getColumnIndex(field, headers);
    let fieldDataType = thisTable["dataTypes"][fieldIndex];
    let newData = [];
    for (let i = 0; i < data.length; i++) {
        if (_testWhereCondition(data[i][fieldIndex], comparator, testValue, fieldDataType)) {
            newData.push(data[i]);
        }
    }
    thisTable["data"] = newData;
    return thisTable;
}

function _copyOneDArray(arr) {
    let copiedArr = [];
    for (let i = 0; i < arr.length; i++) {
        copiedArr.push(arr[i]);
    }
    return copiedArr;
}

function selectDistinct(table, columns) {
    console.log("running selectDistinct(table,columns)");
    console.log("columns:", columns);
    let thisTable = selectColumnsFromTable(table, columns);//returns hard copy
    let data = thisTable["data"];
    // loop through, and add if not already in
    data = removeDuplicates(data);
    thisTable["data"] = data;
    return thisTable;
}



function removeDuplicates(arr) {
    arr = JSON.parse(JSON.stringify(arr));//make hard copy
    let strArray = [];
    for (let i = 0; i < arr.length; i++) {
        strArray.push(JSON.stringify(arr[i]));
    }
    for (let i = arr.length - 1; i >= 0; i--) {
        if (strArray.indexOf(JSON.stringify(arr[i])) !== i) {
            arr.splice(i, 1);
        }
    }
    return arr;
}


function selectColumnsFromTable(table, columns) {
    console.log("running selectColumnsFromTable(table,columns)");
    // console.log("this is table", table);
    //SELECT column1, column2, ...FROM table_name;
    let parentTable = JSON.parse(JSON.stringify(table));
    let parentData = parentTable["data"];
    let parentHeaders = parentTable["headers"];
    let parentDataTypes = parentTable["dataTypes"];
    //construct new table with the right order
    //get headers
    console.log(columns);
    let headers = _copyOneDArray(columns);
    //construct new dataTypes array
    let dataTypes = [];
    for (let i = 0; i < headers.length; i++) {
        //get the index of the same column in the parent table
        let parentHeaderIndex = _getColumnIndex(headers[i], parentHeaders);
        console.log(parentHeaderIndex);
        //use that index to get the datatype
        let thisDataType = parentDataTypes[parentHeaderIndex]
        dataTypes.push(thisDataType);
    }
    //go through each row in the master parent table and 
    // select only the appropriate data for the new table
    let resultData = [];
    for (let i = 0; i < parentData.length; i++) {
        //go through the new header (same as columns) 
        // and push each data cell to each row
        let row = [];
        for (let j = 0; j < headers.length; j++) {
            //get data from parent table cell
            let parentHeaderIndex = _getColumnIndex(headers[j], parentHeaders);
            //console.log(headers[j],parentHeaderIndex);
            row.push(parentData[i][parentHeaderIndex]);
        }
        resultData.push(row);
    }

    let resultTable = {};
    resultTable["headers"] = headers;
    resultTable["data"] = resultData;
    resultTable["dataTypes"] = dataTypes;
    resultTable["name"] = "result";

    return resultTable;

}
function selectColumnsOrderBy(table, columns, sortField, direction = "ASC") {
    //SELECT column1, column2, ... FROM table_name ORDER BY column ASC|DESC;

    //First sort the data by the appropriate column
    let thisTable = JSON.parse(JSON.stringify(table));
    let headers = thisTable["headers"];
    let data = thisTable["data"];
    let dataTypes = thisTable["dataTypes"];

    let sortFieldIndex = _getColumnIndex(sortField, headers);
    let dataType = dataTypes[sortFieldIndex];
    console.log("attempting to bubble sort");
    console.log("sort field", sortField);
    console.log("sort field index", sortFieldIndex);

    console.log(data);
    data = bubbleSort(data, sortFieldIndex, dataType, direction);
    console.log(data);
    //data=_orderData(data,sortFieldIndex,dataType,direction);

    // data=sortByColumn(data,sortFieldIndex,dataType);

    thisTable["data"] = data;//probably not necessary

    //Next return a new table including only the columns requested

    thisTable = selectColumnsFromTable(thisTable, columns);

    return thisTable;

}
function selectColumnsWhere(table, columns, field, comparator, testValue) {
    //SELECT column1, column2, ... FROM table_name WHERE condition;
    let thisTable = JSON.parse(JSON.stringify(table));
    //Quick way, should revise later

    thisTable = selectAllWhere(thisTable, field, comparator, testValue);

    thisTable = selectColumnsFromTable(thisTable, columns);


    //make new headers from columns
    //if field is not in columns, add to header
    return thisTable;


}
function selectInnerJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator) {
    //SELECT Products.ProductID, Products.ProductName, Categories.CategoryName FROM Products INNER JOIN Categories ON Products.CategoryID = Categories.CategoryID;
    //notes: columns are formal . notation; leftColumn/rightColumn are formal, tables are not
    //make smallerLeft Table
    // let lTable = _convertTableToFormalColumns(leftTable);//also makes hard copy, keeps same table name
    // //  adjust headers first
    // let leftHeaders = [];
    // for (let i = 0; i < columns.length; i++) {
    //     if (lTable["headers"].include(columns[i])) {
    //         leftHeaders.push(columns[i]);
    //     }
    //     if (!leftHeaders.includes(leftColumn)) {
    //         leftHeaders.push(columns[i]);
    //     }
    //     lTable = selectColumnsFromTable(lTable, leftHeaders);

    //     let rTable = _convertTableToFormalColumns(rightTable);//also makes hard copy, keeps same table name
    //     //  adjust headers first
    //     let rightHeaders = [];
    //     for (let i = 0; i < columns.length; i++) {
    //         if (rTable["headers"].include(columns[i])) {
    //             rightHeaders.push(columns[i]);
    //         }
    //         if (!rightHeaders.includes(leftColumn)) {
    //             rightHeaders.push(columns[i]);
    //         }
    //         rTable = selectColumnsFromTable(rTable, rightHeaders);

    //         //Inner join all

    //         let resultTable = selectAllInnerJoin(lTable, rTable, leftColumn, rightColumn, comparator);

    //         //now these might contain the leftColumn and rightColumn for comparison, which may not be included in the columns
    //         //therefore request only the columns in the table
    //         //may be able to test and skip, would have to test resultTable["headers"] and columns to make sure they are the same

    //         // select columns from result

    //         resultTable = selectColumnsFromTable(resultTable, columns);


    //         //old smaller code, consider revert to this if not working
    //         // let thisTable = selectAllInnerJoin(_convertTableToFormalColumns(leftTable), _convertTableToFormalColumns(rightTable), leftColumn, rightColumn, comparator);
    //         // thisTable = selectColumnsFromTable(thisTable, columns);
    //         return resultTable;
    //     }
    // }
    let resultTable = selectAllInnerJoin(leftTable, rightTable, leftColumn, rightColumn, comparator);

    resultTable = selectColumnsFromTable(resultTable, columns);
    return resultTable;
}

function updateTableSetColumnValuesWhere(table, columns, values, field, comparator, testValue) {
    //UPDATE table_name SET column1 = `value1`, column2 = `value2` WHERE condition;
    let thisTable = JSON.parse(JSON.stringify(table));
    //loop through data and if field "=" etc testValue;
    //get fieldIndex
    let fieldIndex = _getColumnIndex(field, thisTable["headers"]);
    let dataType = thisTable["dataTypes"][fieldIndex];
    let data = thisTable["data"];
    for (let i = 0; i < data.length; i++) {
        if (_testWhereCondition(data[i][fieldIndex], comparator, testValue, dataType)) {
            //  loop through columns and values
            for (let j = 0; j < columns.length; j++) {
                let thisColumnIndex = _getColumnIndex(columns[j], thisTable["headers"]);
                data[i][thisColumnIndex] = values[j];
            }
        }
    }
    thisTable["data"] = data;//not really necessary
    return thisTable;
}


//////////////INTERNAL FUNCTIONS//////////////
function _convertTableToFormalColumns(table) {
    //add the table name and . before each header
    let thisTable = JSON.parse(JSON.stringify(table));
    let tableName = thisTable["name"];
    for (let i = 0; i < thisTable["headers"].length; i++) {
        thisTable["headers"][i] = tableName + "." + thisTable["headers"][i];
    }
    return thisTable;
}
function _convertTableToSimpleColumns(table) {
    let thisTable = JSON.parse(JSON.stringify(table));
    for (let i = 0; thisTable["headers"].length; i++) {
        let headerStr = thisTable["headers"][i];//get current header element
        let tempArr = headerStr.split(".");//split by .
        tempArr.shift();//remove leftmost element
        thisTable["headers"][i] = tempArr.join(".");//put header back together
    }
    return thisTable;
}
function _merge2Objects(object1, object2) {
}

function _orderData(data, index, dataType = "STRING", direction = "ASC") {
    data.sort(
        function (a, b) {
            if (dataType === "NUMBER") {

                if (Number(a[index]) < Number(b[index])) {
                    return -1;
                }
                if (Number(a[index]) > Number(b[index])) {
                    return 1;
                }
                return 0;
            }
            else {
                if (a[index].toString() < b[index].toString()) {
                    return -1;
                }
                if (a[index].toString() > b[index].toString()) {
                    return 1;
                }
                return 0;
            }
        }
    )
    if (direction === "DESC") {
        data.reverse();
    }
    return data;
}

function sortByColumn(a, colIndex, dataType = "NUMBER",direction="ASC") {
    a=JSON.parse(JSON.stringify(a));
    if (dataType = "NUMBER") {
        function sortFunction(a, b) {



            if(isNaN(Number(a[colIndex]))){
                return 1;
            }
            else if(isNaN(Number(b[colIndex]))){
                return -1;
            }
            else if (Number(a[colIndex]) > Number(b[colIndex])) {
                return -1;
            }
            else if (Number(a[colIndex]) < Number(b[colIndex])) {
                return 1;
            }

            else {

                return 0;
            }
        }
        a.sort(sortFunction);
        if (direction==="DESC"){
            a.reverse();
        }
        return a;
    } else {
        function sortFunction(a, b) {
            if (a[colIndex].toString() === b[colIndex].toString()) {
                return 0;
            }
            else if (a[colIndex].toString() < b[colIndex].toString()) {
                return -1;
            }
            else {
                return 1;
            }
        }
        a.sort(sortFunction);
        if (direction==="DESC"){
            a.reverse();
        }
        return a;
    }
}

// y

// var sorted_a = sortByColumn(a, 2);
function bubbleSort(arrays, columnIndex, dataType = "STRING", direction = "ASC", holdColumnIndex = -1) {

    let arr = JSON.parse(JSON.stringify(arrays));

    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if ((holdColumnIndex===-1)|| (arr[j][holdColumnIndex]===arr[j+1][holdColumnIndex])  ){

                let numberCondition=((Number(arr[j][columnIndex]) > Number(arr[j + 1][columnIndex])) || (isNaN(Number(arr[j + 1][columnIndex]))));
                let stringCondition=(arr[j][columnIndex] > arr[j + 1][columnIndex]);
                if (direction==="DESC"){
                    numberCondition=!numberCondition;
                    stringCondition=!stringCondition;
                }
                if (dataType === "NUMBER") {
                    if (isNaN(Number(arr[j + 1][columnIndex]))) {
                        console.log("isNaN(Number(arr[j+1][columnIndex])) is true:", "-" + arr[j + 1][columnIndex] + "-");
                    }
                    if (numberCondition) {
                        let temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
                else {
                    if (stringCondition) {
                        let temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
    }
    // if (direction === "DESC") {//reverse if called for
    //     arr.reverse();
    // }
    return arr;
}



function _testWhereCondition(field, comparator, testValue, dataType) {
    //=, !=, <>, >=, <=, >, <
    // console.log(field, comparator, testValue, dataType);
    let value;
    if (dataType === "NUMBER") {
        value = Number(field);
        testValue = Number(testValue.toString());
    }
    else {  //default is string
        value = field.toString();
        testValue = testValue.toString();
    }
    // //console.log("testing", value, comparator, testValue, "as", dataType);
    if (comparator === "=") {
        // //console.log("comparator ===");
        if (value === testValue) {
            // //console.log("tests true");
            return true;
        }
        else {
            // //console.log("tests false");
            return false;
        }
    }
    else if ((comparator === "<>") || (comparator === "!=")) {
        // //console.log("comparator !==");
        if (value !== testValue) {
            // //console.log("tests true");
            return true;
        }
        else {
            // //console.log("tests false");
            return false;
        }
    }
    else if (comparator === ">=") {
        //console.log("comparator >=");
        if (value >= testValue) {
            //console.log("tests true");
            return true;
        }
        else {
            //console.log("tests false");
            return false;
        }
    }
    else if (comparator === "<=") {
        //console.log("comparator <=");
        if (value <= testValue) {
            //console.log("tests true");
            return true;
        }
        else {
            //console.log("tests false");
            return false;
        }
    }
    else if (comparator === ">") {
        //console.log("comparator >");
        if (value > testValue) {
            //console.log("tests true");
            return true;
        }
        else {
            //console.log("tests false");
            return false;
        }
    }
    else if (comparator === "<") {
        //console.log("comparator <");
        if (value < testValue) {
            //console.log("tests true");
            return true;
        }
        else {
            //console.log("tests false");
            return false;
        }
    }
}


//////////////DATABASE FUNCTIONS//////////////
function assignTable(database, tableName, table) {
    database["tables"][tableName] = table;
    return table;
}

function dropTable(database, tableName) {
    //DROP TABLE table_name;
    delete database["tables"][tableName];
    let resultTable = {};
    resultTable["name"] = "";
    resultTable["data"] = [];
    resultTable["dataTypes"] = [];
    resultTable["headers"] = [];
    return resultTable;
}
function showTables(database) {
    //SHOW TABLES
    let thisTable = {};
    thisTable["name"] = "SHOW TABLES";
    thisTable["headers"] = ["tableName"];
    thisTable["dataTypes"] = ["STRING"]
    // thisTable["dataTypes"]["tableName"] = "STRING";
    let allTables = database["tables"];
    //console.log(Object.keys(allTables));
    thisTable["data"] = [];
    let keys = Object.keys(allTables);
    for (let i = 0; i < keys.length; i++) {

        let row = [];
        // let row = {};
        // row["tableName"] = keys[i];
        // thisTable["data"].push(keys[i]);
        row.push(keys[i]);
        thisTable["data"].push(row);
    }
    return thisTable;
}

//Works with earlier versions of NodeJS and anywhere replaceAll not available
//from: https://stackoverflow.com/questions/62825358/javascript-replaceall-is-not-a-function-type-error
//author: https://stackoverflow.com/users/9513184/unmitigated
//Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
function myReplaceAll(str, match, replacement) {
    return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);
}

function orderBy(table, column, direction = "ASC",holdIndex=-1) {////////////GOES TO PROCESS
    table = JSON.parse(JSON.stringify(table));
    data = table["data"];
    let columnIndex = _getColumnIndex(column, table["headers"]);
    let dataType = table["dataTypes"][columnIndex];
    //table["data"] = sortByColumn(data,columnIndex,dataType,direction);
    table["data"] = bubbleSort(data, columnIndex, dataType, direction,holdIndex);//hard copy

    return table;
}
function getTable(database, tableName) {
    console.log("-" + tableName + "-");
    console.log(database["tables"]);
    console.log(database["tables"][tableName]);
    return JSON.parse(JSON.stringify(database["tables"][tableName]));
}

function getHeaders(table) {
    let thisTable = JSON.parse(JSON.stringify(table));
    return thisTable["headers"];
}

function selectCount(column, table) {
    let thisTable = JSON.parse(JSON.stringify(table));//make hard copy
    let data = thisTable["data"];
    let resultTable = {};
    resultTable["name"] = "result";
    resultTable["headers"] = [`COUNT(${column})`];
    resultTable["data"] = [];
    let row = [];
    row.push(data.length.toString());
    resultTable["data"].push(row);
    resultTable["dataTypes"] = [];
    resultTable["dataTypes"].push("NUMBER");
    return resultTable;
}

function selectSum(column, table) {
    console.log("selectSum called!!!!!!!!!!!!!!!!");
    let thisTable = JSON.parse(JSON.stringify(table));//make hard copy
    let data = thisTable["data"];
    let resultTable = {};
    resultTable["name"] = "result";
    resultTable["headers"] = [`SUM(${column})`];
    resultTable["data"] = [];
    let row = [];
    let total = 0;
    let fieldIndex = _getColumnIndex(column, thisTable["headers"]);
    console.log("fieldIndex!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", fieldIndex);
    for (let i = 0; i < data.length; i++) {
        total += Number(data[i][fieldIndex]);
    }
    console.log("total", total);
    row.push(total.toString());
    resultTable["data"].push(row);
    resultTable["dataTypes"] = [];
    resultTable["dataTypes"].push("NUMBER");
    return resultTable;

}
function selectAve(column, table) {
    console.log("selectAve called!!!!!!!!!!!!!!!!");
    let thisTable = JSON.parse(JSON.stringify(table));//make hard copy
    let data = thisTable["data"];
    let resultTable = {};
    resultTable["name"] = "result";
    resultTable["headers"] = [`AVE(${column})`];
    resultTable["data"] = [];
    let row = [];

    let fieldIndex = _getColumnIndex(column, thisTable["headers"]);
    console.log("fieldIndex!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", fieldIndex);
    let total = 0;
    let count = 0;
    for (let i = 0; i < data.length; i++) {
        if (data[i][fieldIndex].toString().trim() !== "") {//null
            count += 1;
            total += Number(data[i][fieldIndex]);
        }
    }
    let average = total / count;
    console.log("average: ", average);
    row.push(average.toString());
    resultTable["data"].push(row);
    resultTable["dataTypes"] = [];
    resultTable["dataTypes"].push("NUMBER");
    return resultTable;
    // let thisTable = JSON.parse(JSON.stringify(table));//make hard copy
    // let data = thisTable["data"];
    // let resultTable = {};
    // resultTable["name"] = "result";
    // resultTable["headers"] = [`AVE(${column})`];
    // resultTable["data"] = [];
    // let row = [];

    // let fieldIndex = _getColumnIndex(column, thisTable["headers"]);
    // //console.log("fieldIndex!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", fieldIndex);
    // ///ignore empty strings which if numbers are just null
    // let total = 0;
    // let count = 0;
    // for (let i = 0; i < data.length; i++) {
    //     // console.log("data[i]",data[i]);

    //     if (data[i][fieldIndex].trim() !== "") {
    //         count += 1;
    //         total += Number(data[i][fieldIndex]);
    //     }
    // }
    // let average = total / count;
    // console.log("ave", average);
    // row.push(average.toString());
    // resultTable["data"].push(row);
    // resultTable["dataTypes"] = [];
    // resultTable["dataTypes"].push("NUMBER");
    // return resultTable;

}
//process.selectAdd=selectAdd;
//process.selectAve=selectAve;
//module.exports = {createTable,alterTableAddColumn,alterTableChange,_getColumnIndex,alterTableDropColumn,deleteFromTableWhere,describeTable,insertInto,renameTable,selectAll,selectAllInnerJoin,selectAllCrossJoin,selectAllConcatCompositeKey,selectAllOrderBy,selectAllWhere,_copyOneDArray,selectColumnsFromTable,selectColumnsOrderBy,selectColumnsWhere,selectInnerJoin,updateTableSetColumnValuesWhere,_convertTableToFormalColumns,_convertTableToSimpleColumns,_merge2Objects,_orderData,sortByColumn,bubbleSort,_testWhereCondition,assignTable,dropTable,showTables,getTable};

function selectColumnsUnionAll(table1, columns1, table2, columns2) {
    console.log("columns1:", columns1);
    console.log("columns2:", columns2);
    table1 = JSON.parse(JSON.stringify(selectColumnsFromTable(table1, columns1)));
    table2 = JSON.parse(JSON.stringify(selectColumnsFromTable(table2, columns2)));
    let resultTable = {};
    resultTable["name"] = "result";
    resultTable["headers"] = table1["headers"];
    resultTable["dataTypes"] = table1["dataTypes"];
    resultTable["data"] = table1["data"].concat(table2["data"]);
    console.log(table1["data"]);
    console.log(table2["data"]);
    console.log("table1: ", table1);
    console.log("table2: ", table2);
    console.log("union result", resultTable);
    return resultTable;
}


function applyWhere(table, field, operator, testValue) {
    console.log("IN applyWhere!!!!!!!!!!!!!!!!!!!!!!!!");
    table = JSON.parse(JSON.stringify(table));
    let data = table["data"];
    let headers = table["headers"];
    let dataTypes = table["dataTypes"];
    let fieldIndex = _getColumnIndex(field, headers);
    let fieldDataType = dataTypes[fieldIndex];
    let resultData = [];
    for (let i = 0; i < data.length; i++) {
        // console.log(data[i][fieldIndex],operator,testValue,fieldDataType);
        if (_testWhereCondition(data[i][fieldIndex], operator, testValue, fieldDataType)) {
            resultData.push(data[i]);
        }
    }
    table["data"] = resultData;
    return table;
}

function getColumns(table, columns) {
    table = JSON.parse(JSON.stringify(table));
    let data = table["data"];
    let headers = table["headers"];
    let dataTypes = table["dataTypes"];
    let resultData = [];
    //go through each line of data
    for (let i = 0; i < data.length; i++) {
        //go through columns and make new line of data
        let row = [];
        for (let j = 0; j < columns.length; j++) {
            let thisColumn = columns[j];
            let columnIndex = _getColumnIndex(thisColumn, headers);
            row.push(data[i][columnIndex]);
        }
        resultData.push(row);
    }
    //make new dataTypes
    let resultDataTypes = [];
    for (let i = 0; i < columns.length; i++) {
        let thisColumnIndex = _getColumnIndex(columns[i], headers);
        resultDataTypes.push(dataTypes[thisColumnIndex]);
    }
    table["headers"] = columns;
    table["data"] = resultData;
    table["dataTypes"] = resultDataTypes;
    return table;
}

function orderByOLD(table, column, direction = "ASC") {
    table = JSON.parse(JSON.stringify(table));
    data = table["data"];
    let columnIndex = _getColumnIndex(column, table["headers"]);
    let dataType = table["dataTypes"][columnIndex];
    //table["data"] = sortByColumn(data,columnIndex,dataType,direction);
    table["data"] = bubbleSort(data, columnIndex, dataType, direction);//hard copy

    return table;
}

function distinct(table) {
    table = JSON.parse(JSON.stringify(table));
    table["data"] = removeDuplicates(data);
    return table;
}

function removeDuplicates(arr) {
    arr = JSON.parse(JSON.stringify(arr));
    let strArray = [];
    for (let i = 0; i < arr.length; i++) {
        strArray.push(JSON.stringify(arr[i]));
    }
    for (let i = arr.length - 1; i >= 0; i--) {
        if (strArray.indexOf(JSON.stringify(arr[i])) !== i) {
            arr.splice(i, 1);
        }
    }
    return arr;
}


function applyLoop(table, loopOperation, loopCol, loopGroup) {
    console.log("table passed into applyLoop", table);
    //get distinct loopGroups

    loopOperation = "AVE";
    table = JSON.parse(JSON.stringify(table));
    data = table["data"];
    headers = table["headers"];
    dataTypes = table["dataTypes"];

    //get distinct groups and put in array
    let categories = [];
    let loopGroupIndex = _getColumnIndex(loopGroup, headers);
    let loopGroupDataType = dataTypes[loopGroupIndex];
    let loopColIndex = _getColumnIndex(loopCol, headers);
    console.log("data to get categories from", data);
    for (let i = 0; i < data.length; i++) {
        categories.push(data[i][loopGroupIndex]);
    }
    categories = removeDuplicates(categories);
    console.log("here are the categories", categories);

    let comparator = "=";

    // loopOperation="AVE";
    // loop over categories and get average
    let resultArray = [];
    for (let i = 0; i < categories.length; i++) {
        let category = categories[i];
        let sum = 0;
        let count = 0;
        let ave = 0;
        // console.log("going through category",category);
        for (let j = 0; j < data.length; j++) {
            // console.log("going through data:",data[j]);
            // console.log("comparing ",data[j][loopGroupIndex],"to", category);
            // if (data[j][loopGroupIndex]===category){
            let field = data[j][loopGroupIndex];
            if (_testWhereCondition(field, comparator, category, loopGroupDataType)) {

                sum += Number(data[j][loopColIndex]);
                count += 1;
            }
            ave = sum / count;
            // row.push(ave.toString());
            // row.push(category);            
        }
        console.log("average for category:", category, ave);
        console.log("count for category", category, count);
        console.log("sum for category", sum, count);

        if (loopOperation === "AVE") {
            resultArray.push([ave.toString(), category]);
        }
        else if (loopOperation === "SUM") {
            resultArray.push([sum.toString(), category]);
        }
        else if (loopOperation === "COUNT") {
            resultArray.push([count.toString(), category]);
        }

    }
    console.log("here are grouped results", resultArray);
    //make a result table
    let resultTable = {};
    resultTable["name"] = "result";
    if (loopOperation === "AVE") {
        resultTable["headers"] = ["Ave(" + loopCol + ")", loopGroup];
    }
    else if (loopOperation === "SUM") {
        resultTable["headers"] = ["Sum(" + loopCol + ")", loopGroup];
    }
    else if (loopOperation === "COUNT") {
        resultTable["headers"] = ["Count(" + loopCol + ")", loopGroup];
    }

    resultTable["data"] = resultArray;
    resultTable["dataTypes"] = ["NUMBER", loopGroupDataType];

    console.log("here is the result table", resultTable);

    return resultTable;



}


function simplifyColumnNames(table, columns) {
    table = JSON.parse(JSON.stringify(table));
    let headers = table["headers"];
    console.log("columns!!!!", columns);
    for (let i = 0; i < columns.length; i++) {
        //get current column to simplify ie table.col1;
        let currentColumn = columns[i];
        //is the current column in the headers
        console.log("currentColumn", currentColumn);
        console.log("headers.indexOf(currentColumn)", headers.indexOf(currentColumn));
        if (headers.indexOf(currentColumn) !== -1) {
            //if so get the replaceIndex
            let replaceIndex = headers.indexOf(currentColumn);
            //simplify the name ie col1
            let simpleName = currentColumn.split(".").pop();
            //is col1 already in headers, if so skip
            if (headers.indexOf(simpleName) !== -1) {
                //skip
            }
            else {
                //if not rename the header at replace index with the simple name
                headers[replaceIndex] = simpleName;
            }
        }
    }
    table["headers"] = headers;
    // table["name"]="result";

    console.log("resultTable!!!!!!!!!!!!!!!!!", table);
    return table;
}

function _addEmptyRows(table, numberOfRows) {
    table = JSON.parse(JSON.stringify(table));
    let numberOfCells = table["headers"].length;
    let emptyRow = [];
    for (let i = 0; i < numberOfCells; i++) {
        emptyRow.push("");
    }
    for (let i = 0; i < numberOfRows; i++) {
        table["data"].push(emptyRow);
    }
    return table;


}

function selectSideBySideJoin(leftTable, rightTable, columns) {
    leftTable = JSON.parse(JSON.stringify(leftTable));
    rightTable = JSON.parse(JSON.stringify(rightTable));
    leftData = leftTable["data"];
    rightData = rightTable["data"];
    if (rightData.length > leftData.length) {
        leftTable = _addEmptyRows(leftTable, rightData.length - leftData.length);
        leftData=leftTable["data"];
    }
    else if (rightData.length < leftData.length) {
        rightTable = _addEmptyRows(rightTable, leftData.length - rightData.length);
        rightData=rightTable["data"];
    }

    console.log("LEFT TABLE LENGTH!!!!!!!!",leftData.length);
    console.log("RIGHT TABLE LENGTH!!!!!!!!",rightData.length);


    let resultTable = {};
    let resultData = [];
    //now they are the same length
    let tableLength = leftTable["data"].length;
    for (let i = 0; i < tableLength; i++) {//go through data lines
        let row = [];
        for (let j = 0; j < columns.length; j++) {//go through columsn to build rows
            //get parent
            let tempArray = columns[j].split(".");
            let childField = tempArray.pop();
            let parent = tempArray.join(".");

            //get column index
            //push value onto row
            if (leftTable["name"] === parent) {
                console.log(columns[j], "in left table");
                let index = _getColumnIndex(childField, leftTable["headers"]);
                console.log(index);
                console.log(leftData[i]);
                row.push(leftData[i][index]);
            }
            else {//right table is parent
                console.log(columns[j], "in right table");
                let index = _getColumnIndex(childField, rightTable["headers"]);
                console.log(index);
                console.log(rightData[i]);
                row.push(rightData[i][index]);
            }
        }
        //add row to new data table

        resultData.push(row);
    }
    resultTable["headers"] = columns;
    resultTable["data"] = resultData;
    resultTable["name"] = "result";
    let dataTypes = [];

    //make headers

    for (let i = 0; i < columns.length; i++) {//go through columsn to find headers
        //get parentu
        let tempArray = columns[i].split(".");
        tempArray.pop();
        let parent = tempArray.join(".");
        if (leftTable["name"] === parent) {
            //get column index
            //push value onto row
            let index = _getColumnIndex(columns[i], leftTable["headers"]);
            dataTypes.push(leftTable["dataTypes"][index]);
        }
        else {//right table is parent
            let index = _getColumnIndex(columns[i], rightTable["headers"]);
            dataTypes.push(rightTable["dataTypes"][index]);
        }
    }
    resultTable["dataTypes"] = dataTypes;
    return resultTable;
}

function updateTableComputeColumn(table,column,expression){
    console.log("updateTableComputeColumn(table,column,expression)");
    console.log("column,expression")
    console.log(column,expression);    
    table=JSON.parse(JSON.stringify(table));
    let data=table["data"];
    let headers=table["headers"];
    let dataTypes=table["dataTypes"];
    let colIndex=_getColumnIndex(column,headers);
    for (let i=0;i<data.length;i++){
        let str=_formExpression(expression,data[i],headers,dataTypes);
        console.log("formed Expression:",str);
        let result=myEval(str);
        console.log(result);
        data[i][colIndex]=result.toString();
    }
    console.log(data);
    table["data"]=data;
    return table;
}

function _formExpression(str,row,headers,dataTypes){
    let tokens=_getTokensEnclosedInBackTicks(str);
    tokens=removeDuplicates(tokens);
    for (let i=0;i<tokens.length;i++){
         let strippedToken=tokens[i].replace(/`/g,"").trim();
        let tokenIndex=_getColumnIndex(strippedToken,headers);
        let regex = new RegExp(tokens[i], "g");//form regex from token
        let replaceString="";
        if (dataTypes[tokenIndex]==="STRING"){
            replaceString="\""+row[tokenIndex]+"\".toString()";
        }
        else {
            replaceString="Number(\""+row[tokenIndex]+"\")";
        }
        //str=str.replace(regex,replaceString);
        str=str.replaceAll(tokens[i],replaceString);
    }
    return str;
}

// function _formExpression(str, row, headers, dataTypes) {
//     let tokens = _getTokensEnclosedInBackTicks(str);
//     tokens = removeDuplicates(tokens);
//     for (let i = 0; i < tokens.length; i++) {
//         let strippedToken = tokens[i].replace(/`/g, "").trim();
//         let tokenIndex = _getColumnIndex(strippedToken, headers);
//         let regex = new RegExp(tokens[i], "g");//form regex from token
//         let replaceString = "";
//         if (dataTypes[tokenIndex] === "STRING") {
//             replaceString = "\"" + row[tokenIndex] + "\".toString()";
//         }
//         else {
//             replaceString = "Number(\"" + row[tokenIndex].toString() + "\")";
//         }
//         str = str.replace(regex, replaceString);
//     }
//     console.log("here is the expression", str);
//     return str;
// }

function _getTokensEnclosedInBackTicks(str){
    let regex=/`([^`]+)`/g
    let arr=str.match(regex);
    return arr;
}

function myEval(str){
    let result=Function("return "+str)();
    return result;
}

function whereEval(table, whereExpressionString) { ////////////GOES TO PROCESS
    console.log("IN whereEVAL    !!!!!!!!!!!!!!!!!!!!!!!!");
    table = JSON.parse(JSON.stringify(table));
    let data = table["data"];
    let headers = table["headers"];
    let dataTypes = table["dataTypes"];
    // let fieldIndex = _getColumnIndex(field, headers);
    // let fieldDataType = dataTypes[fieldIndex];
    let resultData = [];
    for (let i = 0; i < data.length; i++) {
        // console.log(data[i][fieldIndex],operator,testValue,fieldDataType);
        ////////////WORKING FOR SIMPLE EXPRESSIONS////////////
        // if (_testWhereCondition(data[i][fieldIndex], operator, testValue, fieldDataType)) {
        //     resultData.push(data[i]);
        // }
        // //////////////////////////////////////////////////////
        let testResult = testWhereExpression(data[i], whereExpressionString, headers, dataTypes);
        console.log("eval results:", testResult);
        if (testResult) {
            resultData.push(data[i]);
        }
    }
    table["data"] = resultData;
    return table;

}

function getDataTypeOfColumn(column, headers, dataTypes) {////////////GOES TO PROCESS
    let index = getIndexOfElement(column, headers);
    let dataType = -1;
    if (index !== -1) {
        dataType = dataTypes[index];
    }
    return dataType;
}
function groupBy(table, groupByList, selectList, aggregateFunctionsList) {////////////GOES TO PROCESS
    //NEED:
    //groupByList           array   [field1,field2]
    //selectList            array   [AVG(field1),field1,field2,Sum(field3)]   ;note, columns must be an aggregate function or in group by list
    //selectListAggregate   array   [AVG,NO,NO,SUM];
    //replacement names     array   [myName,,,];        if AS is in the parse of select list, push here
    //table
    table = hardCopy(table);
    let data = table["data"];
    let headers = table["headers"];
    let dataTypes = table["dataTypes"];
    headers.push("secretKey");
    dataTypes.push("STRING");

    //add secret key to data
    for (let i = 0; i < data.length; i++) {
        let str = "";
        for (let j = 0; j < groupByList.length; j++) {
            let index = getIndexOfElement(groupByList[j], headers);
            str += data[i][index] + "spinach57";
        }
        data[i].push(str);
    }

    //1) make a new data table with headers selectList and secrete key
    //          [AVG(field1),field1,field2,Sum(field3),secretKey]
    let newTable = {};
    newTable["headers"] = hardCopy(selectList);
    let newHeaders = newTable["headers"];
    newHeaders.push("secretKey");
    newTable["data"] = [];
    newTable["dataTypes"] = [];
    let newDataTypes = newTable["dataTypes"];
    aggregateFunctionsList.push("NO");//secretKey is not an aggregate function
    for (let i = 0; i < newHeaders.length; i++) {
        if (aggregateFunctionsList[i] === "NO") {
            newDataTypes.push(process.getDataTypeOfColumn(newHeaders[i], headers, dataTypes));
        }
        else {
            newDataTypes.push("NUMBER");
        }
    }


    let newData = newTable["data"];
    //console.log(newTable);
    // console.log(headers,dataTypes);
    //2) loop through data and make a secret key out the group by list and delimiter
    //          at same time fill in the non aggregate fields

    for (let i = 0; i < data.length; i++) {
        let newTableRow = [];

        //fill in data in headers except the colums that are aggregates
        for (let j = 0; j < newHeaders.length; j++) {

            if (aggregateFunctionsList[j] === "NO") {//not an aggregate function, fill in
                //get column header

                let dataIndex = getIndexOfElement(newHeaders[j], headers);
                newTableRow.push(data[i][dataIndex]);
            }
            else {//an aggregate function, leave blank
                newTableRow.push("");
            }
        }
        newData.push(newTableRow);
    }
    //3) delete duplicate rows
    newTable["data"] = removeDuplicates(newData);
    newData = newTable["data"];

    //4) Now fill in blank data in new table with aggregate functions

    //      go through each column of the new table
    for (let i = 0; i < newHeaders.length; i++) {
        //          is the column an aggregate function
        if (aggregateFunctionsList[i] !== "NO") {
            for (let j = 0; j < newData.length; j++) {
                // go through each row of the new table

                let secretKey = newData[j][newData[j].length - 1];//last element
                // console.log("!!!!!!!!!!!!!", newHeaders[i]);
                // console.log(headers);
                let aggregateColumnIndex = getAggregateInputColumnIndex(newHeaders[i], headers);
                let lastDataElementIndex = headers.length - 1;
                //   go through each row of the old data table
                let count = 0;
                let sum = 0;
                let min;//need to set to the first value in the group
                let max;//
                let firstInGroup = true;

                for (let k = 0; k < data.length; k++) {
                    // console.log("count,sum,min,max",count,sum,min,max);
                    //look for match with secret key and last element in row
                    if (secretKey === data[k][lastDataElementIndex]) {

                        //     is there a match on the secret key?
                        //       if so accumulate the field
                        //console.log("!! match found");
                        let thisNumber = Number(data[k][aggregateColumnIndex]);

                        if (firstInGroup === true) {
                            // console.log("!!!first in group");
                            min = thisNumber;
                            max = thisNumber;
                            firstInGroup = false;

                        }
                        // console.log("min", min, "thisNumber", thisNumber);

                        count = count + 1;
                        sum = sum + thisNumber;
                        //console.log(min, thisNumber);
                        if (min > thisNumber) {
                            min = thisNumber;
                        }
                        if (max < thisNumber) {
                            max = thisNumber;
                        }
                    }
                }
                // console.log("just sweeped through one column");
                // console.log("full list",aggregateFunctionsList);
                // console.log("aggregateFunctionsList[i]","i",i,aggregateFunctionsList[i]);
                // console.log("min",min);
                //COUNT(), SUM(), AVG(), MIN(), and MAX()
                if (aggregateFunctionsList[i] === "COUNT") {
                    newData[j][i] = count.toString();
                }
                else if (aggregateFunctionsList[i] === "SUM") {
                    newData[j][i] = sum.toString();

                } else if (aggregateFunctionsList[i] === "AVG") {
                    newData[j][i] = (sum / count).toString();

                } else if (aggregateFunctionsList[i] === "MIN") {
                    newData[j][i] = min.toString();

                } else if (aggregateFunctionsList[i] === "MAX") {
                    newData[j][i] = max.toString();
                }
                //    accumulatiion finished
            }
        }


    }
    newTable["name"] = "result";

    //onsole.log(JSON.stringify(newTable["data"])===JSON.stringify(newData));



    newHeaders.pop();
    newDataTypes.pop();
    for (let i = 0; i < newData.length; i++) {
        newData[i].pop();
    }

    console.log(newData);
    console.log(newTable["headers"]);

    return newTable;




    //      old table
    //1) make a secret key column
    //2) loop through data and make a secret key our of the group by list and delimiter

    //      fill in new table
    //      
    //      go through each column of the new table
    //          is the column an aggregate function
    //              go through each row of the new table
    //                  go through each row of the old data table
    //                      is there a match on the secret key?
    //                      if so accumulate the field
    //                  accumulatiion finished
    //                  row of new table, colum of new table equal to value
    //                                                
    //      rename new table headers, if applicable    
}

function limit(table, numberOfRecords) {////////////GOES TO PROCESS
    table = hardCopy(table);
    let data = table["data"];
    data = data.slice(0, numberOfRecords);
    table["data"] = data;
    return table;
}

function offset(table, numberOfRecords) {////////////GOES TO PROCESS
    table = hardCopy(table);
    let data = table["data"];
    data = data.slice(numberOfRecords);
    table["data"] = data;
    return table;
}
function distinct(table) {////////////GOES TO PROCESS
    table = JSON.parse(JSON.stringify(table));
    table["data"] = removeDuplicates(table["data"]);
    return table;
}



innerJoin=selectAllInnerJoin;
let process = {};

process.limit=limit;
process.offset=offset;
process.distinct=distinct;
process.groupBy=groupBy;
process.whereEval=whereEval;
process.getDataTypeOfColumn=getDataTypeOfColumn;
process.updateTableComputeColumn=updateTableComputeColumn;
process.selectSideBySideJoin = selectSideBySideJoin;
process.simplifyColumnNames = simplifyColumnNames;
process.applyLoop = applyLoop;
process.getColumns = getColumns;
process.applyWhere = applyWhere;
process.getHeaders = getColumns;
process.orderBy = orderBy;
process.distinct = distinct;
process.removeDuplicates = removeDuplicates;
process.selectFullJoin = selectFullJoin;
process.selectRightJoin = selectRightJoin;
process.selectLeftJoin = selectLeftJoin;
process.selectColumnsUnionAll = selectColumnsUnionAll;
process.createTable = createTable;
process.alterTableAddColumn = alterTableAddColumn;
process.alterTableChange = alterTableChange;
process._getColumnIndex = _getColumnIndex;
process.alterTableDropColumn = alterTableDropColumn;
process.deleteFromTableWhere = deleteFromTableWhere;
process.describeTable = describeTable;
process.insertInto = insertInto;
process.renameTable = renameTable;
process.selectAll = selectAll;
process.selectAllInnerJoin = selectAllInnerJoin;
process.selectAllCrossJoin = selectAllCrossJoin;
process.selectAllConcatCompositeKey = selectAllConcatCompositeKey;
process.selectAllOrderBy = selectAllOrderBy;
process.selectAllWhere = selectAllWhere;
process._copyOneDArray = _copyOneDArray;
process.selectColumnsFromTable = selectColumnsFromTable;
process.selectColumnsOrderBy = selectColumnsOrderBy;
process.selectColumnsWhere = selectColumnsWhere;
process.selectInnerJoin = selectInnerJoin;
process.updateTableSetColumnValuesWhere = updateTableSetColumnValuesWhere;
process._convertTableToFormalColumns = _convertTableToFormalColumns;
process._convertTableToSimpleColumns = _convertTableToSimpleColumns;
process._merge2Objects = _merge2Objects;
process._orderData = _orderData;
process.sortByColumn = sortByColumn;
process.bubbleSort = bubbleSort;
process._testWhereCondition = _testWhereCondition;
process.assignTable = assignTable;
process.dropTable = dropTable;
process.showTables = showTables;
process.getTable = getTable;
process.getHeaders = getHeaders;
process.selectDistinct = selectDistinct;
process.selectCount = selectCount;
process.selectSum = selectSum;
process.selectAve = selectAve;
</script>
<script>
//const process = require("./arrayTableFunctions");
// let database = {}
// database["tables"] = {};
// console.log(process);

function sqlQuery(strSQL) {
    console.log("processing", strSQL);
    strSQL = strSQL.split(";").join("").trim();

    if (/INSERT\s+INTO\s+(.+)\s+(SELECT)/.test(strSQL)) {
        console.log("sql identified as INSERT INTO [A SELECT STATEMENT]");
        return parseInsertIntoASelectStatement(strSQL);
    }
    else if (/SELECT\s+(.+)\s+FROM\s+(.+)\s+SIDEBYSIDE\s+JOIN\s+(.+)/.test(strSQL)) {
        console.log("sql identified as SELECT column1, column2, ... FROM table1 SIDEBYSIDE JOIN table2");
        return parseSelectSideBySideJoin(strSQL);
    }
    if (/CREATE\s+TABLE\s+(.+)\s*\((.+)\)/.test(strSQL)) {
        console.log("sql identified as CREATE TABLE statement");
        return parseCreateTable(strSQL);
    }
    else if (/RENAME\s+TABLE\s+(.+)\s+TO\s+(.+)/.test(strSQL)) {
        console.log("sql identified as RENAME TABLE oldTable TO newTable");
        return parseRenameTable(strSQL);
    }
    else if (/SHOW\s+TABLES/.test(strSQL)) {
        console.log("sql identified as SHOW TABLES statement");
        return parseShowTables(strSQL);
    }
    else if (/DESCRIBE\s+(.+)/.test(strSQL)) {
        console.log("sql identified as DESCRIBE table statement");
        return parseDescribeTable(strSQL);
    }
    else if (/DROP\s+TABLE\s+(.+)/.test(strSQL)) {
        console.log("sql identified as DROP table statement");
        return parseDropTable(strSQL);
    }

    else if (/SELECT\s+(.+)\s+FROM\s+(.+)\s+UNION\s+ALL\s+SELECT\s+(.+)\s+FROM\s+(.+)/.test(strSQL)) {//////goes before general
        console.log("sql identified as SELECT col1,col2,etc FROM table1 UNION ALL SELECT colb1,colb2,etc FROM table2");
        return parseSelectColumnsUnionAll(strSQL);
    }
    else if (/SELECT/.test(strSQL)) {
        console.log("sql identified as general select statment");
        console.log("generic SELECT!");
        return parseGenericSelect(strSQL);
    }
    else if (/INSERT\s+INTO\s+(.+)\s*\((.+)\)\s+VALUES\s+\((.+)\)/g.test(strSQL)) {
        //  /INSERT\s+INTO\s+(.+)\s*\((.+)\)\s+VALUES\s+\((.+)\)/g;
        console.log("sql identified as INSERT INTO statement");
        return parseInsertInto(strSQL);
    }
    else if (/ALTER\s+TABLE\s+(.+)\s+ADD\s+(.+)\s+(.+)/.test(strSQL)) {
        console.log("sql identified as ALTER TABLE ADD COLUMNstatement");
        return parseAlterTableAddColumn(strSQL);
    }
    else if (/ALTER\s+TABLE\s+(.+)\s+DROP\s+COLUMN\s(.+)/.test(strSQL)) {
        console.log("sql identified as ALTER TABLE DROP COLUMN statement");
        return parseAlterTableDropColumn(strSQL);
    }
    else if (/ALTER\s+TABLE\s+(.+)\s+CHANGE\s+(.+)\s+(.+)\s+(.+)/.test(strSQL)) {
        console.log("sql identified as ALTER TABLE CHANGE statement");
        return parseAlterTableChange(strSQL);
    }
    else if (/UPDATE\s+(.+)\s+COMPUTE\s+(.+)=(.+)/.test(strSQL)) {
        //UPDATE customers COMPUTE total_amount = total_amount * 1.1; 
        console.log("sql identified as UPDATE table COMPUTE col = an expression with fields in backticks");
        return parseUpdateTableComputeColumn(strSQL);
    }
    else if (/UPDATE\s+(.+)\s+SET\s+(.+)\s+WHERE\s+(.+)/.test(strSQL)) {
        console.log("sql identified as UPDATE table columns to values WHERE");
        return parseUpdateTableSetColumnValuesWhere(strSQL);
    }
    else if (/DELETE\s+FROM\s+(.+)\s+WHERE\s(.+)/.test(strSQL)) {
        console.log("sql identified as DELETE FROM table_name WHERE condition");
        return parseDeleteFromTableWhere(strSQL);
    }
    else if (/SIMPLIFY\s+COLUMN\s+NAMES\s+(.+)\s+FROM\s+(.+)/.test(strSQL)) {
        console.log("sql Identified as SIMPLIFY COLUMN NAMES (col1,col2,etc...) FROM tableName");
        return parseSimplifyColumnNames(strSQL);
    }
    else {
        console.log("sql statement not identified.");
        let emptyTable = {};
        emptyTable["name"] = "Result";
        emptyTable["data"] = [];
        emptyTable["headers"]=["SQL statement not recognized: "+strSQL];
        emptyTable["dataTypes"] = ["STRING"];
        return emptyTable;
    }

}



function parseSimplifyColumnNames(strSQL) {
    let regex = /SIMPLIFY\s+COLUMN\s+NAMES\s+(.+)\s+FROM\s+(.+)/
    let regexResult = regex.exec(strSQL);
    let columnString = regexResult[1].trim();
    let tableName = regexResult[2].trim();

    //get and clean columns

    if (columnString === "*") {
        let tempTable = process.getTable(database, tableName);
        columns = process.getHeaders(tempTable);
    }
    else {
        columns = columnString.split(",");
    }
    //clean columns
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
    }

    let table = process.getTable(database, tableName);
    let resultTable = process.simplifyColumnNames(table, columns);

    return process.assignTable(database, tableName, resultTable);

}

////////////////////////////PARSE STATEMENTS/////////////////////////////
// parseInsertIntoASelectStatement(strSQL)
// parseSelectInnerJoin(strSQL)
// parseCreateTable(strSQL)
// parseRenameTable(strSQL)
// parseShowTables(strSQL)
// parseDescribeTable(strSQL)
// parseDropTable(strSQL)
// parseSelectCount(strSQL)
// parseSelectSum(strSQL)
// parseSelectAvg(strSQL)
// parseSelectColumnsUnionAll(strSQL)
// parseGenericSelect(strSQL)
// parseInsertInto(strSQL)
// parseAlterTableAddColumn(strSQL)
// parseAlterTableDropColumn(strSQL)
// parseAlterTableChange(strSQL)
// parseUpdateTableSetColumnValuesWhere(strSQL)
// parseDeleteFromTableWhere(strSQL)

// parseInsertIntoASelectStatement(strSQL)


function parseInsertIntoASelectStatement(strSQL) {

    console.log("in parseInsertIntoASelectStatement");
    //get the table name
    //get the select statement

    //INSERT INTO [A SELECT STATEMENT]
    let regex = /INSERT\s+INTO\s+(.+)\s+SELECT (.+)/;

    //need tableName
    let tempArray = strSQL.split("SELECT");
    console.log("tempArray", tempArray);
    let tableName = tempArray[0].replace("INSERT", "").replace("INTO", "").trim();//also removes first part of array
    console.log("tableName", tableName);
    tempArray[0] = "";
    let selectStatement = tempArray.join("SELECT").trim();
    console.log("selectStatement", selectStatement);
    //need selectStatement


    // let regexResult = regex.exec(strSQL);
    // let tableName = regexResult[1];
    // let selectStatement = "SELECT " + regexResult[2];

    //console.log(regexResult);

    //INSERT INTO petDirectory SELECT pets.ownerID, owners.firstname, pets.name FROM owners INNER JOIN pets ON owners.PRIMARY_KEY = pets.ownerID;

    //send the select statement through sqlQuery

    let selectResultTable = sqlQuery(selectStatement);


    console.log("before rename");
    console.log(selectResultTable);
    selectResultTable = process.renameTable(selectResultTable, tableName);
    // console.log("after renaming");
    // console.log(selectResultTable);
    return process.assignTable(database, tableName, selectResultTable);

    //recieve table back

    //send table name and table to a new function insertIntoSelect(tableName,table);
    //this will be a new table, rename the table here


    //return process.parseInsertIntoASelectStatement(tableName, selectResultTable);
}
// parseSelectInnerJoin(strSQL)
function parseSelectInnerJoin(strSQL) {
    // SELECT Products.ProductID, Products.ProductName, Categories.CategoryName FROM Products INNER JOIN Categories ON Products.CategoryID = Categories.CategoryID;
    let regex = /SELECT\s+(.+)\s+FROM\s+(.+)\s+INNER\s+JOIN\s+(.+)\s+ON\s+(.+)\s*(\!\=|\<\>|\>\=|\<\=|\>|\<|\=)\s*(.+)/;
    let regexResult = regex.exec(strSQL);
    let columnsString = regexResult[1];
    let leftTableName = regexResult[2];
    let rightTableName = regexResult[3];
    let leftColumn = regexResult[4];
    let comparator = regexResult[5];
    let rightColumn = regexResult[6];
    console.log(regexResult);
    //make columns array
    let columns = [];
    if (columnsString === "*") {
        let leftTempHeaders = _convertTableToFormalColumns(process.getTable(database, leftTableName))["headers"];
        let rightTempHeaders = _convertTableToFormalColumns(process.etTable(database, rightTableName))["headers"];
        columns = leftTempHeaders.concat(rightTempHeaders);
    }
    else {
        columns = columnsString.split(",");
    }
    //clean columns
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
    }

    let leftTable = process.getTable(database, leftTableName);
    let rightTable = process.getTable(database, rightTableName);

    return process.selectInnerJoin(leftTable, rightTable, columns, leftColumn, rightColumn, comparator);
}



function parseSelectSideBySideJoin(strSQL) {
    let regex = /SELECT\s+(.+)\s+FROM\s+(.+)\s+SIDEBYSIDE\s+JOIN\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let columnsString = regexResult[1];
    let leftTableName = regexResult[2];
    let rightTableName = regexResult[3];
    //make columns array
    let columns = [];
    if (columnsString === "*") {
        let leftTempHeaders = _convertTableToFormalColumns(process.getTable(database, leftTableName))["headers"];
        let rightTempHeaders = _convertTableToFormalColumns(process.getTable(database, rightTableName))["headers"];
        columns = leftTempHeaders.concat(rightTempHeaders);
    }
    else {
        columns = columnsString.split(",");
    }
    //clean columns
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
    }

    let leftTable = process.getTable(database, leftTableName);
    let rightTable = process.getTable(database, rightTableName);

    return process.selectSideBySideJoin(leftTable, rightTable, columns);
}




// parseCreateTable(strSQL)
function parseCreateTable(strSQL) {
    // CREATE TABLE table_name (column1 datatype, column2 datatype, column3 datatype...);
    let regex = /CREATE\s+TABLE\s+(.+)\s*\((.+)\)/;
    let regexResult = regex.exec(strSQL);
    let tableName = regexResult[1].trim();
    let pairStatement = regexResult[2];
    //get pairs, irregardless of spaces
    let pairs = pairStatement.split(",");
    //split into parts using space
    for (let i = 0; i < pairs.length; i++) {
        pairs[i] = pairs[i].split(" ");
    }
    //remove empties entries;
    let finalPairs = [];
    for (let i = 0; i < pairs.length; i++) {
        let tempPairs = [];
        for (let j = 0; j < pairs[i].length; j++) {
            if (pairs[i][j] !== "") {
                tempPairs.push(pairs[i][j]);
            }
        }
        finalPairs.push(tempPairs);
    }

    //console.log("finalPairs", finalPairs);

    let columns = [];
    let dataTypes = [];
    for (let i = 0; i < finalPairs.length; i++) {
        columns.push(finalPairs[i][0]);
        dataTypes.push(finalPairs[i][1]);
    }
    // console.log("tableName: " + tableName);
    // console.log("pairs: "+finalPairs);
    // console.log("columns: " + columns);
    // console.log("data types: " + dataTypes);

    let resultTable = process.createTable(tableName, columns, dataTypes);

    process.assignTable(database, tableName, resultTable);

    // processNewTable(thisTable);
    return resultTable;
}
// parseRenameTable(strSQL)
function parseRenameTable(strSQL) {
    //RENAME oldTale TO newTable;
    console.log("sql identified as RENAME oldTable TO newTable");
    let regex = /RENAME\s+TABLE\s+(.+)\s+TO\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let tableName = regexResult[1];
    // console.log(tableName);
    let newName = regexResult[2];
    // console.log(newName);
    let table = process.getTable(database, tableName);
    // console.log("table from parseRenameTable------------",table);
    table = process.renameTable(table, newName);
    // console.log(table);
    process.dropTable(database, tableName);
    // console.log("sending to process.assignTable");
    // console.log("database",database);
    // console.log("tableName",tableName);
    // console.log("table",table);
    return process.assignTable(database, newName, table);
}
// parseShowTables(strSQL)
function parseShowTables(strSQL) {
    console.log(strSQL);

    return process.showTables(database);
}
// parseDescribeTable(strSQL)
function parseDescribeTable(strSQL) {
    //DESCRIBE table_name;
    let regex = /DESCRIBE\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    ////console.log(regexResult);
    let tableName = regexResult[1];
    console.log("tableName: " + tableName);

    let table = process.getTable(database, tableName);
    return process.describeTable(table);
}
// parseDropTable(strSQL)
function parseDropTable(strSQL) {
    //console.log("parseDropTable called");
    let regex = /DROP\s+TABLE\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    ////console.log(regexResult);
    let tableName = regexResult[1];
    console.log("tableName: " + tableName);

    return process.dropTable(database, tableName);
}
// parseSelectCount(strSQL)
function parseSelectCount(strSQL) {
    let regex = /SELECT\s+COUNT\((.+)\)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let column = regexResult[1];
    let tableName = regexResult[2];
    let table = process.getTable(database, tableName);
    // let resultTable=process.selectCount(column,table);
    let resultTable = process.selectCount(column, table);
    console.log("result from COUNT:", resultTable);
    return resultTable;
}

// parseSelectSum(strSQL)
function parseSelectSum(strSQL) {
    let regex = /SELECT\s+SUM\((.+)\)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let column = regexResult[1];
    let tableName = regexResult[2];
    let table = process.getTable(database, tableName);
    let resultTable = process.selectSum(column, table);
    return resultTable;
}
// parseSelectAvg(strSQL)

function parseSelectAvg(strSQL) {
    let regex = /SELECT\s+AVE\((.+)\)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let column = regexResult[1];
    let tableName = regexResult[2];
    let table = process.getTable(database, tableName);
    let resultTable = process.selectAve(column, table);
    return resultTable;
}


// parseSelectColumnsUnionAll(strSQL)
function parseSelectColumnsUnionAll(strSQL) {
    let regex = /SELECT\s+(.+)\s+FROM\s+(.+)\s+UNION\s+ALL\s+SELECT\s+(.+)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let columnString1 = regexResult[1];
    let table1Name = regexResult[2];
    let columnString2 = regexResult[3];
    let table2Name = regexResult[4];
    let table1 = process.getTable(database, table1Name);
    let table2 = process.getTable(database, table2Name);
    let columns1 = [];
    if (columnString1.trim() === "*") {
        columns1 = getHeaders(table1);
    }
    else {
        columns1 = columnString1.split(",");
    }
    for (let i = 0; i < columns1.length; i++) {
        columns1[i] = columns1[i].trim();
    }
    let columns2 = [];
    if (columnString2.trim() === "*") {
        columns2 = getHeaders(table2);
    }
    else {
        columns2 = columnString2.split(",");
    }
    for (let i = 0; i < columns2.length; i++) {
        columns2[i] = columns2[i].trim();
    }

    return process.selectColumnsUnionAll(table1, columns1, table2, columns2);

}
// parseGenericSelect(strSQL)
// function parseGenericSelect(strSQL) {

// }

function parseGenericSelectOLD(strSQL) {



    let orderClause = false;
    let whereClause = false;
    let distinct = false;
    let loopClause = false;
    let direction = "ASC";
    let orderField = "";
    let whereField = "";
    let whereComparator = "=";
    let whereTestValue = "";
    let loopOperation = "AVE";
    let loopCol = "";
    let loopGroup = "";

    if (strSQL.indexOf("ORDER") !== -1) {
        orderClause = true;
        orderString = "ORDER " + strSQL.split("ORDER")[1].trim();
        strSQL = strSQL.split("ORDER")[0].trim();
        if (orderString.indexOf("ASC") !== -1) {
            orderString = orderString.split("ASC").join("").trim();
            direction = "ASC";
        }
        else if (orderString.indexOf("DESC") !== -1) {
            orderString = orderString.split("DESC").join("").trim();
            direction = "DESC";
        }
        let orderRegex = /ORDER\s+BY\s+(.+)/;
        orderField = orderRegex.exec(orderString)[1];
        //remove orderClause and get tokens
        console.log(orderString);
        console.log(orderField);
        console.log(direction);
    }
    if (strSQL.indexOf("LOOP") !== -1) {
        loopClause = true;
        //get and remove loop clause
        let loopClauseString = strSQL.match(/LOOP.+/)[0];
        strSQL = strSQL.replace(/LOOP.+/, "");
        let loopRegex = /LOOP\s+(.+)\((.+)\)\s+BY\s+(.+)/;
        let loopRegexResult = loopRegex.exec(loopClauseString);
        loopOperation = loopRegexResult[1].trim();
        loopCol = loopRegexResult[2].trim();
        loopGroup = loopRegexResult[3].trim();
        console.log(loopClause, loopClauseString);
        console.log(loopOperation, loopCol, loopGroup);
        console.log("new strSQL", strSQL);
    }

    if (strSQL.indexOf("WHERE") !== -1) {
        whereClause = true;
        whereString = strSQL.split("WHERE")[1].trim();


        whereComparator = /(!=|<>|>=|<=|>|<|=)/.exec(whereString)[1];
        whereField = whereString.split(whereComparator)[0].trim();
        whereTestValue = whereString.split(whereComparator)[1].trim().replace(/`/g, "");
        strSQL = strSQL.split("WHERE")[0].trim();

        console.log("whereString", whereString);
        console.log(whereField);
        console.log(whereComparator);
        console.log(whereTestValue);

        //remove where clause and get tokens
    }
    if (strSQL.indexOf("DISTINCT") !== -1) {
        distinct = true;
        strSQL = strSQL.split("DISTINCT").join("");
        //remove DISTINCT from sql statement;
    }

    console.log("RESULTS\n--------");
    console.log("direction", direction);
    console.log("orderField", orderField);
    console.log("whereField", whereField);
    console.log("whereComparator", whereComparator);
    console.log("whereTestValue", whereTestValue);
    console.log("loopOperation", loopOperation);
    console.log("loopCol", loopCol);
    console.log("loopGroup", loopGroup);
    console.log("core sql string", strSQL);

    //get columns
    //SELECT CustomerName, City FROM Customers
    let regex = /SELECT\s+(.+)\s+FROM(.+)/
    let regexResult = regex.exec(strSQL);
    console.log("regexResults", regexResult);
    let columnString = regexResult[1].trim();
    let tableName = regexResult[2].trim();
    //get and clean columns

    if (columnString === "*") {
        let tempTable = process.getTable(database, tableName);
        columns = process.getHeaders(tempTable);
    }
    else {
        columns = columnString.split(",");
    }
    //clean columns
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
    }

    let table = process.getTable(database, tableName);
    let resultTable = process.selectAll(table);

    if (whereClause) {
        resultTable = process.applyWhere(resultTable, whereField, whereComparator, whereTestValue);
    }

    if (loopClause) {
        resultTable = process.applyLoop(resultTable, loopOperation, loopCol, loopGroup);
    }

    if (columnString !== "*") {
        resultTable = process.getColumns(resultTable, columns);
    }
    if (orderClause) {
        console.log("ORDERING the table:" + orderField + direction);
        resultTable = process.orderBy(resultTable, orderField, direction);
    }
    if (distinct) {
        resultTable = process.selectDistinct(resultTable, columns);
    }

    return resultTable;
}
// parseInsertInto(strSQL)
function parseInsertInto(strSQL) {
    // INSERT INTO table_name (column1, column2, column3, ...) VALUES (`value1`, `value2`, `value3`, ...); 
    let regex = /INSERT\s+INTO\s+(.+)\s*\((.+)\)\s+VALUES\s+\((.+)\)/g;


    let regexResult = regex.exec(strSQL);
    //console.log(regexResult);
    let tableName = regexResult[1].trim();
    let columnsString = regexResult[2];
    let valuesString = regexResult[3];

    //make columns array
    let columns = columnsString.split(",");
    //remove empty column entries and clean each entry
    let tempArr = [];
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
        if (columns[i] !== "") {
            tempArr.push(columns[i]);
        }
    }
    columns = tempArr;
    //console.log(columns);

    //make values array
    let values = valuesString.split(",");
    //remove empty column entries and clean each entry
    tempArr = [];
    for (let i = 0; i < values.length; i++) {
        values[i] = values[i].trim();
        values[i] = values[i].replace(/`/g, "");
        if (values[i] !== "") {
            tempArr.push(values[i]);
        }
    }
    values = tempArr;
    //console.log(tableName);
    //console.log(values);

    let table = process.getTable(database, tableName);
    let resultTable = process.insertInto(table, columns, values);

    return (process.assignTable(database, tableName, resultTable));
}
// parseAlterTableAddColumn(strSQL)
function parseAlterTableAddColumn(strSQL) {
    // ALTER TABLE table_name ADD column_name datatype; 
    let regex = /ALTER\s+TABLE\s+(.+)\s+ADD\s+(.+)\s+(.+)/g;
    let regexResult = regex.exec(strSQL);
    //console.log(regexResult);
    let tableName = regexResult[1].trim();
    let columnName = regexResult[2].trim();
    let dataType = regexResult[3].trim();
    console.log("table: " + tableName);
    console.log("column: " + columnName);
    console.log("data type: " + dataType);

    let table = process.getTable(database, tableName);


    let resultTable = process.alterTableAddColumn(table, columnName, dataType);

    return (process.assignTable(database, tableName, resultTable));
}
// parseAlterTableDropColumn(strSQL)
function parseAlterTableDropColumn(strSQL) {
    //console.log("parseAlterTableDropColumn");
    // ALTER TABLE table_name DROP COLUMN column_name;  
    let regex = /ALTER\s+TABLE\s+(.+)\s+DROP\s+COLUMN\s(.+)/g;
    let regexResult = regex.exec(strSQL);
    //console.log(regexResult);
    let tableName = regexResult[1].trim();
    let columnName = regexResult[2].trim();
    // console.log("table: " + tableName);
    // console.log("column " + columnName);

    let table = process.getTable(database, tableName);
    let resultTable = process.alterTableDropColumn(table, columnName);
    return (process.assignTable(database, tableName, resultTable));


}
// parseAlterTableChange(strSQL)
function parseAlterTableChange(strSQL) {
    // ALTER TABLE table_name CHANGE samename samename newdatatype;     
    let regex = /ALTER\s+TABLE\s+(.+)\s+CHANGE\s+(.+)\s+(.+)\s+(.+)/g;
    let regexResult = regex.exec(strSQL);
    //console.log(regexResult);
    let tableName = regexResult[1];
    let oldName = regexResult[2];
    let newName = regexResult[3];
    let dataType = regexResult[4];
    // console.log("table: " + tableName);
    // console.log("old column name: " + oldName);
    // console.log("new column name: " + newName);
    // console.log("new data type: " + dataType);

    let table = process.getTable(database, tableName);

    let resultTable = process.alterTableChange(table, oldName, newName, dataType);

    return (process.assignTable(database, tableName, resultTable));
}
// parseUpdateTableSetColumnValuesWhere(strSQL)

function parseUpdateTableComputeColumn(strSQL) {
    //UPDATE customers COMPUTE total_amount = total_amount * 1.1; 
    let regexResult = /UPDATE\s+(.+)\s+COMPUTE\s+(.+)=(.+)/.exec(strSQL);

    let tableName = regexResult[1].trim();
    let column = regexResult[2].trim();
    let expression = regexResult[3].trim();
    console.log("tableName,column,expression");
    console.log(tableName, column, expression);


    let table = process.getTable(database, tableName);

    let resultTable = process.updateTableComputeColumn(table, column, expression);

    return (process.assignTable(database, tableName, resultTable));

}

function parseUpdateTableSetColumnValuesWhere(strSQL) {
    //   /UPDATE\s+(.+)\s+SET\s+(.+)\s+WHERE\s+(.+)/

    //UPDATE table_name SET column1 = `value1`, column2 = `value2`, ... WHERE condition;   ///////DONE///////
    //UPDATE\s+(.+)\s+SET\s+(.*)\s+WHERE(.*)(=|!=|<>|>=|<=|>|<)(.+)/.exec(strSQL);
    //UPDATE\s+(.+)\s+SET\s+(.+)\s+WHERE(.+)
    let compareString = strSQL.split("WHERE")[1];
    let comparator = /(!=|<>|>=|<=|>|<|=)/.exec(compareString)[1];
    let field = compareString.split(comparator)[0].trim();
    let testValue = compareString.split(comparator)[1].trim().replace(/`/g, "");

    let firstString = strSQL.split("WHERE")[0];
    console.log("firstString", firstString);

    let regex = /UPDATE\s+(.+)\s+SET\s+(.+)/;
    let regexResult = regex.exec(firstString);

    //console.log(regexResult);
    let tableName = regexResult[1].trim();
    let pairString = regexResult[2];

    // // //process pairs string
    let keyValuePairs = pairString.split(",");
    let finalPairs = [];
    //go through key value pairs and clean up.
    for (let i = 0; i < keyValuePairs.length; i++) {
        finalPairs.push(keyValuePairs[i].split("="));
    }

    let columns = [];
    let values = [];
    for (let i = 0; i < finalPairs.length; i++) {
        columns.push(finalPairs[i][0].trim());
        values.push(finalPairs[i][1].trim().replace(/`/g, ""));
    }

    console.log("table name", tableName);
    console.log("columns", columns);
    console.log("values", values);
    console.log("field:", field);
    console.log("comparator", comparator);
    console.log("testValue", testValue);

    let table = process.getTable(database, tableName);

    //let resultTable = process.updateTableSetColumnValuesWhere(table, columns, values, field, comparator, testValue);
    let whereClause = getWhereExpressionStringWithJavascriptOperators(strSQL);



    let resultTable = updateTableSetColumnValuesWhereNew(table, columns, values, whereClause);



    return (process.assignTable(database, tableName, resultTable));
}

function updateTableSetColumnValuesWhereNew(table, columns, values, whereClause) {//Move to process
    //UPDATE table_name SET column1 = `value1`, column2 = `value2` WHERE condition;
    let thisTable = JSON.parse(JSON.stringify(table));
    //loop through data and if field "=" etc testValue;
    //get fieldIndex
    let headers = thisTable["headers"];
    let dataTypes = thisTable["dataTypes"];
    //let fieldIndex = _getColumnIndex(field, thisTable["headers"]);
    //let dataType = thisTable["dataTypes"][fieldIndex];
    let data = thisTable["data"];
    for (let i = 0; i < data.length; i++) {
        // if (_testWhereCondition(data[i][fieldIndex], comparator, testValue, dataType)) {
        if (testWhereExpression(data[i], whereClause, headers, dataTypes)) {
            //  loop through columns and values
            for (let j = 0; j < columns.length; j++) {
                let thisColumnIndex = _getColumnIndex(columns[j], thisTable["headers"]);
                data[i][thisColumnIndex] = values[j];
            }
        }
    }
    thisTable["data"] = data;//not really necessary
    return thisTable;
}

function deleteFromTableWhereNew(table, whereClause) {
    //DELETE FROM table_name WHERE condition;
    let thisTable = JSON.parse(JSON.stringify(table));

    let data = thisTable["data"];
    let headers = table["headers"];
    let dataTypes = table["dataTypes"];
    //get dataType
    // let index = _getColumnIndex(field, thisTable["headers"]);
    // let whereDataType = thisTable["dataTypes"][index];
    //loop through data backwards and remove if where condition is positive
    for (let i = data.length - 1; i >= 0; i--) {
        //test where condition
        let row = data[i];
        // let thisFieldValue = row[index];
        // if (_testWhereCondition(thisFieldValue, comparator, testValue, whereDataType)) {
        if (testWhereExpression(row, whereClause, headers, dataTypes)) {
            data.splice(i, 1);
        }
    }
    return thisTable;
}




// parseDeleteFromTableWhere(strSQL)
function parseDeleteFromTableWhere(strSQL) {
    // DELETE FROM table_name WHERE condition; 
    let compareString = strSQL.split("WHERE")[1];
    let whereClause = getWhereExpressionStringWithJavascriptOperators(strSQL);

    console.log("compareString", compareString);
    let comparator = /(!=|<>|>=|<=|>|<|=)/.exec(compareString)[1];
    console.log(comparator);
    let field = compareString.split(comparator)[0].trim();
    let testValue = compareString.split(comparator)[1].trim().replace(/`/g, "");

    let firstString = strSQL.split("WHERE")[0];
    console.log("firstString", firstString);

    let tableName = /DELETE\s+FROM\s+(.+)/.exec(firstString)[1].trim();
    console.log("table name", tableName);
    // let tableName=regexResult[1].trim();
    // let field=regexResult[2].trim();
    // let comparator=regexResult[3];
    // let testValue=regexResult[4];
    // console.log("table name",tableName);
    console.log("field:", field);
    console.log("comparator", comparator);
    console.log("testValue", testValue);
    //console.log(/(=|!=|<>|>=|<=|>|<)(.+)/.exec(strSQL));
    let table = process.getTable(database, tableName);
    let resultTable = deleteFromTableWhereNew(table, whereClause);
    return process.assignTable(database, tableName, resultTable);
}








/////////////////EXTRA FUNCTIONS////////////////////////////////
















function parseSelectColumnsWhere(strSQL) {
    // SELECT column1, column2, ... FROM table_name WHERE condition;
    let compareString = strSQL.split("WHERE")[1];
    let comparator = /(!=|<>|>=|<=|>|<|=)/.exec(compareString)[1];
    let field = compareString.split(comparator)[0].trim();
    let testValue = compareString.split(comparator)[1].trim().replace(/`/g, "");
    console.log("field:", field);
    console.log("comparator", comparator);
    console.log("test value", testValue);
    let firstString = strSQL.split("WHERE")[0];
    console.log("firstString", firstString);
    // SELECT column1, column2, ...FROM table_name;
    let regex = /SELECT\s+(.+)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(firstString);
    let tableName = regexResult[2].trim();
    let columnsString = regexResult[1];
    let columns = columnsString.split(",");
    //clean columns
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
    }
    console.log("columns:", columns);
    console.log("table name:", tableName);


    let table = process.getTable(database, tableName);
    /////////////////////////////////////////
    return process.selectColumnsWhere(table, columns, field, comparator, testValue);
}


function parseSelectColumnsFromTable(strSQL) {
    // SELECT column1, column2, ...FROM table_name;
    let regex = /SELECT\s+(.+)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let columnsString = regexResult[1];
    let columns = [];
    let tableName = regexResult[2].trim();
    if (columnsString.trim() === "*") {
        //get columns from table
        let tempTable = process.getTable(database, tableName);
        columns = process.getHeaders(tempTable);
    }
    else {
        columns = columnsString.split(",");
    }
    //clean columns
    for (let i = 0; i < columns.length; i++) {
        columns[i] = columns[i].trim();
    }

    console.log("columns:", columns);
    console.log("table name:!!!!!", tableName);

    let table = process.getTable(database, tableName);

    return process.selectColumnsFromTable(table, columns);
}
function parseSelectAll(strSQL) {
    // SELECT * FROM table_name;                                                            ///////DONE///////
    let tableName = strSQL.split("FROM")[1].trim();
    console.log("table name:", tableName);
    let table = process.getTable(database, tableName);
    return process.selectAll(table);
}

function parseSelectAllConcatCompositeKey(strSQL) {
    let regex = /SELECT\s+\*.*\s+CONCAT\s*\((.+)\)\s*AS\s+(.+)\s+FROM\s+(.+)/;
    let regexResult = regex.exec(strSQL);
    let combineKeysString = regexResult[1];
    let keyName = regexResult[2];
    let tableName = regexResult[3];
    console.log(combineKeysString);
    console.log(keyName);
    console.log(tableName);

    //split combineKeyString
    let keys = combineKeysString.split(",");
    let tokenIsAField = [];
    //clean each element
    for (let i = 0; i < keys.length; i++) {
        keys[i] = keys[i].trim();
        // keys[i]=keys[i]
        keys[i] = keys[i].replace(/\'/g, '"');//convert single quotes to doubles
        // keys[i]=keys[i].replace(/\"/g,"`");//convert double quotes to backticks
        if (keys[i].indexOf('"') !== -1) {//has backtick
            tokenIsAField.push(false);
        }
        else {
            tokenIsAField.push(true);
        }
        keys[i] = keys[i].replace(/\"/g, "");
    }
    // console.log(keys);
    // console.log(tokenIsAField);

    let table = process.getTable(database, tableName);
    let resultTable = process.selectAllConcatCompositeKey(table, keyName, keys, tokenIsAField);

    return resultTable;
}




///////////////////////////////NEW FUNCTIONS NEED TO SORT OUT

function getIndexOfElement(element, array) {
    return array.indexOf(element);
}

function getInitialSelectList(strSQL) {
    let regex = /SELECT\s+(.+)\s+FROM/;
    let selectListStr = regex.exec(strSQL)[1];
    selectListStr = selectListStr.replace("DISTINCT", "").trim();
    let selectList = selectListStr.split(",");
    selectList = trimArrayElements(selectList);
    return selectList;
}

function getAggregatesFromInitialSelectList(initialSelectList) {
    //COUNT(), SUM(), AVG(), MIN(), and MAX()
    let aggArr = [];
    for (let i = 0; i < initialSelectList.length; i++) {
        if (initialSelectList[i].indexOf("COUNT") !== -1) {
            aggArr.push("COUNT");
        }
        else if (initialSelectList[i].indexOf("SUM") !== -1) {
            aggArr.push("SUM");
        }
        else if (initialSelectList[i].indexOf("AVG") !== -1) {
            aggArr.push("AVG");
        }
        else if (initialSelectList[i].indexOf("MIN") !== -1) {
            aggArr.push("MIN");
        }
        else if (initialSelectList[i].indexOf("MAX") !== -1) {
            aggArr.push("MAX");
        }
        else {
            aggArr.push("NO");
        }
    }
    return aggArr;
}



function getSelectListAliases(initialSelectList, aggArr) {
    let aliasNames = [];
    for (let i = 0; i < initialSelectList.length; i++) {
        let str = initialSelectList[i];
        if (aggArr[i] === "NO") {
            aliasNames.push(str);
        }
        else {
            //check to see if AS is present 
            if (str.indexOf("AS") !== -1) {//Alias present get it
                aliasNames.push(str.split("AS")[1].trim());
            }
            else {//Alias not present make it from AVG(), etc
                //split by "(" and lowercase
                let tempArr = str.split("(");
                // let littleFunctionName = tempArr[0].toLowerCase();
                let littleFunctionName = tempArr[0];
                tempArr[0] = littleFunctionName;
                let thisName = tempArr.join("(");
                aliasNames.push(thisName);
            }
        }
    }
    return aliasNames;
}

function trimArrayElements(arr) {////////////GOES TO PROCESS
    for (let i = 0; i < arr.length; i++) {
        arr[i] = arr[i].trim();
    }
    return arr;
}

function getGroupByList(strSQL) {
    strSQL = strSQL + " ";
    let regex = /GROUP\s+BY\s+(.+?)\s+(HAVING|ORDER|LIMIT|OFFSET)*/;
    let regexResult = regex.exec(strSQL);
    let groupByString = regexResult[1];
    let groupByList = groupByString.split(",");
    groupByList = trimArrayElements(groupByList);
    return groupByList;
}

_getColumnIndex = getIndexOfElement;

function hardCopy(someObject) {////////////GOES TO PROCESS
    return JSON.parse(JSON.stringify(someObject));
}




function parseGenericSelect(strSQL) {
    // SELECT DISTINCT column, AGG_FUNC(column_or_expression), â¦
    // FROM mytable
    //     JOIN another_table
    //       ON mytable.column = another_table.column
    //     WHERE constraint_expression
    //     GROUP BY column
    //     HAVING constraint_expression
    //     ORDER BY column ASC/DESC
    //     LIMIT count OFFSET COUNT;
    //    // SELECT DISTINCT column, AGG_FUNC(column_or_expression) FROM mytable JOIN another_table ON mytable.column = another_table.column WHERE constraint_expression GROUP BY column HAVING constraint_expression ORDER BY column ASC/DESC LIMIT count OFFSET COUNT;


    //
    // SELECT DISTINCT <TOP_specification> <select_list>
    // FROM <left_table>
    // <join_type> JOIN <right_table>
    // ON <join_condition>
    // WHERE <where_condition>
    // GROUP BY <group_by_list>
    // HAVING <having_condition>
    // ORDER BY <order_by_list></order_by_list>
    //
    // SELECT DISTINCT column, AGG_FUNC(column_or_expression), â¦
    // FROM leftTable
    //     joinType JOIN rightTable
    //       ON joinCondition
    //     WHERE whereCondition
    //     GROUP BY groupByList
    //     HAVING havingCondition
    //     ORDER BY orderByList/direction
    //     LIMIT count OFFSET COUNT;
    strSQL = strSQL.replace(/\;/g, "");
    strSQL = strSQL + " ";

    console.log(strSQL);
    ///////////////////JUST FOR TESTING////////////////
    // let table = database["tables"]["Products"];

    //console.log(table);
    ///////////////////////////////////////////////////
    // let data = table["data"];
    // let headers = table["headers"];
    // let dataTypes = table["dataTypes"];

    //query is identified as a SELECT query, not process it more
    // let join = false;
    // let where = false;
    // let group = false;
    // let having = false;
    // let distinct = false;
    // let order = false;
    // let limit = false;
    // let offset = false;

    let initialSelectList = getInitialSelectList(strSQL);
    let aggregateFunctionsList = getAggregatesFromInitialSelectList(initialSelectList);
    let selectList = getSelectListAliases(initialSelectList, aggregateFunctionsList);

    console.log("SELECT LIST ", selectList);

    let leftTableNameRegex = /FROM\s+(.+?)\s+/;
    let leftTableNameRegexResult = leftTableNameRegex.exec(strSQL);
    let leftTableName = leftTableNameRegexResult[1];
    // console.log(leftTableNameRegexResult);
    let leftTable;
    try {
        leftTable = process.getTable(database, leftTableName);
    } catch (error) {
        return getErrorTable("Trouble getting: "+leftTableName+" while parsing: "+strSQL);
    }

    // if (selectList[0]==="*"){
    //     selectList=leftTable["headers"];
    // }
    console.log("selectList", selectList);

    console.log(leftTableName);
    //leftTable, rightTable, leftColumn, rightColumn, comparator

    if (strSQL.indexOf("JOIN") !== -1) {
        let regex = /SELECT\s+(.+)\s+FROM\s+(.+)\s+INNER\s+JOIN\s+(.+)\s+ON\s+(.+?)\s*(\!\=|\<\>|\>\=|\<\=|\>|\<|\=)\s*(.+?)\s/;
        let regexResult = regex.exec(strSQL);
        // let columnsString = regexResult[1];
        //let leftTableName = regexResult[2];
        let rightTableName = regexResult[3];
        let leftColumn = regexResult[4];
        let comparator = regexResult[5];
        let rightColumn = regexResult[6];
        //let leftTable=getTable(database,leftTableName);
        let rightTable = process.getTable(database, rightTableName);
        /////////////JOIN/////////////////////
        //scan string to see if it is a join
        //if so, get leftTable, joinType, righTable,joinCondition
        //process the table and get the joined table
        if (strSQL.indexOf("INNER") !== -1) {
            table = innerJoin(leftTable, rightTable, leftColumn, rightColumn, comparator);
        }


    }
    else {
        table = leftTable;
        tableName = leftTableName;
    }
    if (strSQL.indexOf("WHERE") !== -1) {
        let whereExpressionString = getWhereExpressionStringWithJavascriptOperators(strSQL);
        table = process.whereEval(table, whereExpressionString);
    }
    if (strSQL.indexOf("GROUP") !== -1) {
        console.log("GROUP BY clause found");
        //////////////GROUP BY/////////////////////
        //see if there is group by
        //if so, get groupByList and selectList
        //                      RULES: if a column is in the select list, it must be an aggregate function or in the groupbylist;
        //                      practically speaking, for this program, require that the groupbylist is in the select columns;
        //                      need to first look at the groupbylist and get unique combinations of the groups
        //                      so, loop through the data once to get the groups
        //  
        //                      i.e.    SELECT AVG(field1) AS myName,field1,field2,SUM(field3) FROM table GROUP BY field1,field2

        //NEED:
        //groupByList           array   [field1,field2]
        //selectList            array   [AVG(field1),field1,field2,Sum(field3)]   ;note, columns must be an aggregate function or in group by list
        //selectListAggregate   array   [AVG,NO,NO,SUM];
        //replacement names     array   [myName,,,];        if AS is in the parse of select list, push here
        //table

        //      New table

        let groupByList = getGroupByList(strSQL);


        //return;
        table = process.groupBy(table, groupByList, selectList, aggregateFunctionsList);
    }


    if (strSQL.indexOf("HAVING") !== -1) {
        //////////////////HAVING////////////////////////
        //see if there is having
        //if so, get havingCondition
        //process the table


        let havingExpressionString = getHavingExpressionStringWithJavascriptOperators(strSQL);
        console.log("The having expression", havingExpressionString);
        table = whereEval(table, havingExpressionString);//no difference in function
    }

    /////////////////SELECT COLUMNS////////////////////
    //select columns clause
    if (selectList[0] !== "*") {
        table = selectColumnsFromTable(table, selectList);
    }

    if (strSQL.indexOf("DISTINCT") !== -1) {
        /////////////////DISTINCT///////////////////////
        //see if there is distinct
        table = process.distinct(table);
    }

    if (strSQL.indexOf("ORDER") !== -1) {
        ///////////////////ORDER BY/////////////////////////
        //see if there is order by
        let orderList = getOrderByList(strSQL);
        console.log("!!!!!!!orderList", orderList);
        let orderDirections = getOrderByDirections(strSQL);
        console.log("order Directions", orderDirections);

        headers = table["headers"];
        //process each ordering
        for (let i = 0; i < orderList.length; i++) {
            if (i === 0) {
                table = orderBy(table, orderList[i], orderDirections[i], -1);
            }
            else {
                lastOrderColumn = orderList[i - 1];
                lastOrderIndex = getIndexOfElement(orderList[i - 1], headers);
                table = orderBy(table, orderList[i], orderDirections[i], lastOrderIndex);
            }
        }

        //         SELECT * FROM Customers
        // ORDER BY Country ASC, CustomerName DESC;

    }

    if (strSQL.indexOf("OFFSET") !== -1) {
        ////////////////////OFFSET//////////////////////////
        //see if there is offset
        let numberOfRecords = getOffsetNumber(strSQL);
        console.log(numberOfRecords);
        table = process.offset(table, numberOfRecords);
    }

    if (strSQL.indexOf("LIMIT") !== -1) {
        ///////////////////LIMIT///////////////////////
        //see if there is limit
        let numberOfRecords = getLimitNumber(strSQL);
        console.log(numberOfRecords);
        table = process.limit(table, numberOfRecords);
    }
    console.log(table);
    console.log(table["data"].length);
    return table;
}

function getErrorTable(error){
    let errorTable = {};
    errorTable["name"] = "Error";
    errorTable["data"] = [];
    errorTable["headers"]=[error];
    errorTable["dataTypes"] = ["STRING"];
    return errorTable;
}

function getStringInBetweenTwoStrings(str, str1, str2) {
    let regexString = str1 + "(.+)" + str2;
    let regex = new RegExp(regexString);
    let regexResult = regex.exec(str);
    // console.log(regexResult[1]);
    //console.log(regexResult);
    if (regexResult === null) {
        return str;
    }
    else {
        return regexResult[1];
    }
}
function getWhereExpressionStringWithJavascriptOperators(strSQL) {
    //whittle down where expression string
    let whereExpressionString = strSQL.split("WHERE")[1];
    whereExpressionString = " " + whereExpressionString;
    whereExpressionString = getStringInBetweenTwoStrings(whereExpressionString, " ", "GROUP");
    // console.log("!", whereExpressionString);
    whereExpressionString = getStringInBetweenTwoStrings(whereExpressionString, " ", "ORDER");
    console.log("!", whereExpressionString);
    whereExpressionString = getStringInBetweenTwoStrings(whereExpressionString, " ", "LIMIT");
    console.log("!", whereExpressionString);
    whereExpressionString = getStringInBetweenTwoStrings(whereExpressionString, " ", "OFFSET");
    console.log("!", whereExpressionString);
    //make javascript operator replacements
    whereExpressionString = "(" + whereExpressionString + ")";
    whereExpressionString = whereExpressionString.replace(/AND/g, "&&");
    whereExpressionString = whereExpressionString.replace(/OR/g, "||");
    whereExpressionString = whereExpressionString.replace(/=/g, "===");
    whereExpressionString = whereExpressionString.replace(/<>/g, "!==");
    whereExpressionString = whereExpressionString.replace(/!=/g, "!==");
    whereExpressionString = whereExpressionString.replace(/!====/g, "!==");
    whereExpressionString = whereExpressionString.replace(/!===/g, "!==");
    whereExpressionString = whereExpressionString.replace(/<===/g, "<=");
    whereExpressionString = whereExpressionString.replace(/>===/g, ">=");
    return whereExpressionString;
}

function getHavingExpressionStringWithJavascriptOperators(strSQL) {
    //     HAVING constraint_expression
    //     ORDER BY column ASC/DESC
    //     LIMIT count OFFSET COUNT;
    //whittle down having expression string
    let havingExpressionString = strSQL.split("HAVING")[1];
    havingExpressionString = " " + havingExpressionString;
    havingExpressionString = getStringInBetweenTwoStrings(havingExpressionString, " ", "ORDER");
    // console.log("!", havingExpressionString);
    havingExpressionString = getStringInBetweenTwoStrings(havingExpressionString, " ", "LIMIT");
    console.log("!", havingExpressionString);
    havingExpressionString = getStringInBetweenTwoStrings(havingExpressionString, " ", "OFFSET");
    console.log("!", havingExpressionString);
    //make javascript operator replacements
    havingExpressionString = "(" + havingExpressionString + ")";
    havingExpressionString = havingExpressionString.replace(/AND/g, "&&");
    havingExpressionString = havingExpressionString.replace(/OR/g, "||");
    havingExpressionString = havingExpressionString.replace(/=/g, "===");
    havingExpressionString = havingExpressionString.replace(/<>/g, "!==");
    havingExpressionString = havingExpressionString.replace(/!=/g, "!==");
    havingExpressionString = havingExpressionString.replace(/!====/g, "!==");
    havingExpressionString = havingExpressionString.replace(/!===/g, "!==");
    havingExpressionString = havingExpressionString.replace(/<===/g, "<=");
    havingExpressionString = havingExpressionString.replace(/>===/g, ">=");
    return havingExpressionString;
}

// SELECT * FROM Customers
// ORDER BY Country ASC, CustomerName DESC;

function getOrderByList(strSQL) {
    let orderByString = strSQL.split(/ORDER\s+BY/)[1];
    orderByString = " " + orderByString;
    orderByString = getStringInBetweenTwoStrings(orderByString, " ", "LIMIT");
    orderByString = getStringInBetweenTwoStrings(orderByString, " ", "OFFSET");
    let orderByList = orderByString.split(",");
    for (let i = 0; i < orderByList.length; i++) {
        orderByList[i] = orderByList[i].replace("ASC", "");
        orderByList[i] = orderByList[i].replace("DESC", "");
    }
    orderByList = trimArrayElements(orderByList);
    return orderByList;
}


function getLimitNumber(strSQL) {
    let limitString = strSQL.split("LIMIT")[1];
    limitString = " " + limitString;
    limitString = getStringInBetweenTwoStrings(limitString, " ", "OFFSET");
    limitString = limitString.trim();
    return limitString;
}

function getOffsetNumber(strSQL) {
    let offsetString = strSQL.split("OFFSET")[1];
    offsetString = " " + offsetString;
    offsetString = getStringInBetweenTwoStrings(offsetString, " ", "LIMIT");
    offsetString = offsetString.trim();
    return offsetString;
}


function getOrderByDirections(strSQL) {
    let orderByString = strSQL.split(/ORDER\s+BY/)[1];
    console.log(orderByString);
    orderByString = " " + orderByString;
    orderByString = getStringInBetweenTwoStrings(orderByString, " ", "LIMIT");
    orderByString = getStringInBetweenTwoStrings(orderByString, " ", "OFFSET");
    let orderByList = orderByString.split(",");
    let orderByDirections = [];
    for (let i = 0; i < orderByList.length; i++) {
        if (orderByList[i].indexOf("DESC") !== -1) {
            orderByDirections.push("DESC");
        }
        else {
            orderByDirections.push("ASC");
        }
    }

    return orderByDirections;
}

function getAggregateInputColumnIndex(strContainingFunctionName, headers) {
    let field = strContainingFunctionName;
    let regex = /\((.+)\)/;
    let regexResult = regex.exec(strContainingFunctionName);
    if (regexResult !== null) {
        field = regexResult[1].trim();
    }
    //let index=headers.indexOf(strContainingFunctionName);

    let index = headers.indexOf(field);
    // console.log("-" + field + "-");
    // console.log(headers);
    // console.log("index!!!!!!!!!!!!!!", index);
    return index;
}

function testWhereExpression(row, expressionString, headers, dataTypes) {/////////////TO PROCESS
    let expression = _formExpression(expressionString, row, headers, dataTypes);
    console.log(expression);
    let result = myEval(expression);
    return result;
}



</script>
<script>
let sqlOptionsArray = [["SELECT Columns","SELECT CustomerName, City, Country FROM Customers;"],
["SELECT *","SELECT * FROM Customers;"],
["SELECT DISTINCT","SELECT DISTINCT Country FROM Customers;"],
["SELECT WHERE with STRING","SELECT * FROM Customers WHERE `Country` = 'Mexico';-->if evaluating by string, use single quotes"],
["SELECT WHERE with NUMBER","SELECT * FROM Customers WHERE `CustomerID` = 1;-->if evaluating as number, use no quotes"],
["SELECT WHERE with complex clause","SELECT * FROM Customers WHERE `Country` = 'Germany' AND (`City` = 'Berlin' OR `CustomerID` > 3);"],
["SELECT WITH ORDER BY","SELECT * FROM Customers ORDER BY Country;"],
["SELECT WITH ORDER BY DESC","SELECT * FROM Customers ORDER BY Country DESC;"],
["SELECT WITH double ORDER BY","SELECT * FROM Customers ORDER BY Country ASC, CustomerName DESC;"],
["INSERT INTO table VALUES","INSERT INTO Customers (CustomerName, City, Country) VALUES (`Cardinal`, `Stavanger`, `Norway`);-->always use backticks, same for STRING OR NUMBER"],
["UPDATE TABLE WHERE","UPDATE Customers SET ContactName = `Alfred Schmidt`, City = `Frankfurt` WHERE `CustomerID` = 1;-->always use backticks for values, in where clause use single quotes for STRING, nothing for NUMBER"],
["DELTE FROM table WHERE","DELETE FROM Customers WHERE `CustomerName`='Alfreds Futterkiste';-->in WHERE clause, use `` to enclose field, '' for STRINGS, nothing for NUMBER"],
["DELETE FROM table WHERE alphabetical","DELETE FROM Products WHERE `Price`<=10 OR `ProductName`>='G';"],
["SELECT WITH LIMIT","SELECT * FROM Customers LIMIT 3;"],
["SELECT WITH OFFSET","SELECT * FROM Customers LIMIT 3 OFFSET 3;"],
["SELECT WITH ORDER BY AND LIMIT","SELECT * FROM Customers ORDER BY Country LIMIT 3;"],
["SELECT MIN","SELECT MIN(Price) FROM Products GROUP BY MIN(PRICE);"],
["SELECT MAX","SELECT MAX(Price) FROM Products GROUP BY MAX(Price);"],
["SELECT COUNT","SELECT COUNT(ProductID) FROM Products GROUP BY COUNT(ProductID);"],
["SELECT AVG","SELECT AVG(Price) FROM Products GROUP BY AVG(Price);"],
["SELECT SUM","SELECT SUM(Quantity) FROM OrderDetails GROUP BY SUM(Quantity);"],
["INNER JOIN","SELECT Orders.OrderID, Customers.CustomerName FROM Orders INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;"],
["UNION ALL","SELECT City FROM Customers UNION ALL SELECT City FROM Suppliers;"],
["SELECT COUNT with GROUP BY","SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country;"],
["SELECT COUNT with ORDER BY and ORDER BY","SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country ORDER BY COUNT(CustomerID) DESC;"],
["SELECT COUNT AS alias WITH GROUP BY and ORDER BY","SELECT COUNT(CustomerID) AS medalCount, Country FROM Customers GROUP BY Country ORDER BY medalCount DESC;"],
["SELECT COUNT INNER JOIN with GROUP BY","SELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID GROUP BY Shippers.ShipperName;"],
["SELECT COUNT AS alias with GROUP BY and HAVING","SELECT COUNT(CustomerID) AS myCount, Country FROM Customers GROUP BY Country HAVING `myCount`>5;"],
["SELECT COUNT with GROUP BY and HAVING","SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country HAVING `COUNT(CustomerID)`>5;"],
["SELECT COUNT AS alias WITH GROUP BY and ORDER BY","SELECT COUNT(CustomerID) AS myCount, Country FROM Customers GROUP BY Country HAVING `myCount` > 5;"],
["SELECT COUNT WITH GROUP BY and ORDER BY","SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country HAVING `COUNT(CustomerID)` > 5 ORDER BY COUNT(CustomerID) DESC;"],
["SELECT COUNT AS alias INNER JOIN with GROUP BY and HAVING","SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID GROUP BY Employees.LastName HAVING `NumberOfOrders`>10;"],
["SELECT COUNT AS alias INNER JOIN with WHERE GROUP BY and HAVING","SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID WHERE `Employees.LastName` = 'Davolio' OR `Employees.LastName` = 'Fuller' GROUP BY Employees.LastName HAVING `NumberOfOrders` > 25;"],
["SELECT COUNT INNER JOIN with WHERE GROUP BY and HAVING","SELECT Employees.LastName, COUNT(Orders.OrderID) FROM Orders INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID WHERE `Employees.LastName` = 'Davolio' OR `Employees.LastName` = 'Fuller' GROUP BY Employees.LastName HAVING `COUNT(Orders.OrderID)` > 25;"],
["INSERT INTO a SELECT statement","INSERT INTO smallTable SELECT * FROM Customers LIMIT 3 OFFSET 3;-->INSERT INTO newTableName <any select statement> creates a new table"],
["ALTER TABLE ADD","ALTER TABLE Products ADD compositeKey STRING;"],
["UPDATE TABLE COMPUTE","UPDATE Products COMPUTE compositeKey = `ProductID`+'myDelimiter'+`SupplierID`;"],
["SIMPLIFY COLUMN NAMES *","--SIMPLIFY COLUMN NAMES * FROM someTable;-->Used to convert table.col1 to col1 where able"],
["SIMPLIFY COLUMN NAMES column list","--SIMPLIFY COLUMN NAMES col1,col2 FROM someTable;"],
["SIDEBYSIDE JOIN with column list","--SELECT table1.col1, table2.col2 FROM table1 SIDEBYSIDE JOIN table2;-->joins tables from left and right indescriminately"],
["SIDEBYSIDE JOIN *","--SELECT * FROM table1 SIDEBYSIDE JOIN table2;"],
["RENAME TABLE","--RENAME TABLE Orders TO CompletedOrders;"],
["SHOW TABLES","SHOW TABLES;"],
["DESCRIBE table","DESCRIBE Suppliers;"],
["ALTER TABLE CHANGE column","--ALTER TABLE Suppliers CHANGE SupplierID SupplierID_STRING STRING;"],
["ALTER TABLE ADD column","ALTER TABLE Customers ADD Email STRING;"],
["ALTER TABLE DROP column","ALTER TABLE Customers DROP COLUMN Email;"],
["CREATE TABLE","--CREATE TABLE Persons (PersonID NUMBER, LastName STRING, FirstName STRING, Address STRING, City STRING);"],
["DROP TABLE","--DROP TABLE Shippers;"]];
</script>
<script>
/////////////////////////////////////////////////
//              INITIALIZATION                 //
/////////////////////////////////////////////////

let database = {};
database["tables"] = {};
let lastQueryResults = {};//updated when short table formed

document.getElementById("run-button-1").addEventListener("click", runSQLQuery);
document.getElementById("run-button-2").addEventListener("click", runSQLQuery);
document.getElementById("save-query-1").addEventListener("click", saveQuery);
document.getElementById("save-query-2").addEventListener("click", saveQuery);
document.getElementById("load-query-1").addEventListener("click", loadQuery);
document.getElementById("load-query-2").addEventListener("click", loadQuery);
document.getElementById("cancel-formsave-button").addEventListener("click", cancelSaveForm);
document.getElementById("loadDatabaseButton").addEventListener("click", loadDatabase);
document.getElementById("saveDatabaseButton").addEventListener("click", saveDatabase);
document.getElementById('load-button').addEventListener('click', loadCSV);
document.getElementById('convert-CSV-button').addEventListener("click", convertCSV);
document.getElementById('add-table-button').addEventListener("click", showTableInputForm);
document.getElementById('save-table-button').addEventListener("click", saveTable);
document.getElementById("load-tradewinds").addEventListener("click", loadTradewinds);
document.getElementById("load-SQLSamples").addEventListener("click", loadSQLSamples);
document.getElementById("show-all-query").addEventListener("click", showAllQuery);
addEventListenersToEditAndDeleteButtons();
addEventListenersToSaveAndCopyTextButtons();
populateSelect(sqlOptionsArray);
makeSelectCopyToClipboard();
window.onbeforeunload = askCloseWindow;
function askCloseWindow() {
    return "Are you sure?";
}
window.addEventListener('error', function (event) {
    alert('Error occurred: ' + event.message + ' at ' + event.filename + ':' + event.lineno);
});

/////////////////////////////////////////////////
//                  FUNCTIONS                  //
/////////////////////////////////////////////////
function loadTradewinds() {
    if (confirm("This will overwrite the current database.  Are you sure?")) {
        database = JSON.parse(JSON.stringify(tradewinds));
        cancelSaveForm();
        refreshDataTablesOnLeft();
    }
}

function loadSQLSamples() {
    if (confirm("This will overwrite the lower SQL entry text area.  Are you sure?")) {
        let str = "";
        for (let i = 0; i < sqlOptionsArray.length; i++) {
            str += sqlOptionsArray[i][1] + "\n";
        }
        document.getElementById("sqlInputTextarea-2").value = str;
    }
}

function makeSelectCopyToClipboard() {
    document.getElementById('sqlOptionsSelect').addEventListener('change', function () {
        const selectedOption = this.value;
        navigator.clipboard.writeText(selectedOption).then(() => {
            console.log('Copied to clipboard: ' + selectedOption);
            //alert("Copied to Clipboard:\n\n" + selectedOption);
            showPopup("Copied to Clipboard: " + selectedOption, 1500);
        }).catch(err => {
            console.error('Failed to copy: ', err);
        });
    });
}

function populateSelect(sqlOptionsArray) {
    let selectElement = document.getElementById('sqlOptionsSelect');
    for (let i = 0; i < sqlOptionsArray.length; i++) {
        console.log(sqlOptionsArray[i]);
        let option = document.createElement('option');
        option.value = sqlOptionsArray[i][1];
        option.textContent = sqlOptionsArray[i][0];
        selectElement.appendChild(option);
    }
    selectElement.selectedIndex = -1;
}


function showPopup(message, timeInMilliseconds) {
    const popup = document.getElementById('popup');
    popup.innerHTML = message;
    popup.style.display = 'block';

    setTimeout(() => {
        popup.style.display = 'none';
    }, timeInMilliseconds);
}

function showAllQuery() {
    let htmlTable = tableObjectToHTMLTable(lastQueryResults, false, true);
    document.getElementById("right-side-results").innerHTML = htmlTable;
    document.getElementById("row-count").innerHTML = lastQueryResults["data"].length.toString();
}

function saveQuery(evt) {
    let id = evt.target.id.split("-").pop().trim();
    let textAreaName = "sqlInputTextarea-" + id.toString();
    let sqlText = document.getElementById(textAreaName).value;
    saveToFile(sqlText, "query", ".sql", true);
}

function loadQuery(evt) {
    if (confirm("This will overwrite the current contents in this query window.  Are you sure?")) {
        let id = evt.target.id.split("-").pop().trim();
        let textAreaName = "sqlInputTextarea-" + id.toString();
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.sql';
        input.onchange = function (e) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function (event) {
                let contents = event.target.result.trim();
                document.getElementById(textAreaName).value = contents;
            };
            reader.readAsText(file);
        };
        input.click();
    }
}

function removeInlineComments(inputString) {//# Remove Inline Comments from Multi-line String
    let result = '';
    let inComment = false;
    for (let i = 0; i < inputString.length; i++) {
        if (inputString[i] === '-' && inputString[i + 1] === '-') {
            inComment = true;
            i++; // Skip the next character
        } else if (inComment && inputString[i] === '\n') {
            inComment = false; // End of comment
            result += inputString[i]; // Add the newline character
        } else if (!inComment) {
            result += inputString[i];
        }
    }
    return result;
}

function runSQLQuery(evt) {
    document.getElementById("csvResult").value = "...";
    document.getElementById("right-side-results").innerHTML = "...";
    document.getElementById("row-count").innerHTML = "";
    let id = evt.target.id.split("-").pop();
    let textAreaName = "sqlInputTextarea-" + id.toString();
    let sqlText = document.getElementById(textAreaName).value;
    document.getElementById("right-side").style.visibility = "visible";
    sqlText = removeInlineComments(sqlText);
    sqlText = sqlText.replace("\r\n", "\n");
    sqlText = sqlText.replace("\n", " ");
    let commands = sqlText.split(";")
    //remove empty elements in array;
    commands = removeEmptyElementsOrWhitespace(commands);
    let results = {};
    for (let i = 0; i < commands.length; i++) {
        console.log(commands[i]);
        // alert("running query");
        results = sqlQuery(commands[i]);
        console.log(results);
    }
    lastQueryResults = results;
    
    plotDataset=[];
    plotDataset.push(results["headers"]);

    plotDataset=plotDataset.concat(results["data"]);
    console.log("plotDataset");
    console.log(plotDataset);
    plotDatasetHeaders = plotDataset[0];
    populateSelectElementsOfPlotHeaders();
    
    drawScatterPlot();

    let htmlTable = tableObjectToHTMLTable(results, false, false);
    refreshDataTablesOnLeft();
    document.getElementById("right-side-results").innerHTML = htmlTable;
    console.log("results ready to make CSV", results);
    console.log(results);
    document.getElementById("csvResult").value = tableObjectToCSV(results);
    //update row count
    document.getElementById("row-count").innerHTML = results["data"].length.toString();
    // console.log(results);
    document.getElementById("right-side").style.visibility = "visible";
    return results;
}

function removeEmptyElementsOrWhitespace(arr) {
    let result = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].trim() !== '') {
            result.push(arr[i]);
        }
    }
    return result;
}

function cancelSaveForm() {
    refreshDataTablesOnLeft();
    document.getElementById('table-input-form').style.display = "none";
    document.getElementById('middle-section').style.display = "flex";
    document.getElementById('top-section').style.display = "flex";
    document.getElementById('output').innerHTML = "";

}

function saveObjectAsJSON(obj) {
    const json = JSON.stringify(obj);
    const date = new Date().toISOString().split('T')[0];
    const filename = `database_${date}.json`;
    const blob = new Blob([json], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
}

function saveDatabase() {
    saveObjectAsJSON(database);
}

function clearTableInputForm() {
    document.getElementById("table-name").value = "";
    document.getElementById("csv-input").value = "";
    document.getElementById("output").innerHTML = "";
    revmoveEventListenersFromTableHeaders();
}

function loadDatabase() {
    if (confirm("This will overwrite the current database.  Are you sure?")) {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = function (e) {
            const file = e.target.files[0];
            // console.log(file["name"]);
            // let fileName=file["name"];
            let tempArr = file["name"].split(".");
            tempArr.pop();
            document.getElementById("table-name").value = tempArr.join(".");
            const reader = new FileReader();
            reader.onload = function (event) {
                database = JSON.parse(event.target.result);
                cancelSaveForm();
                refreshDataTablesOnLeft();
                // let contents = event.target.result.trim();
                // document.getElementById('csv-input').value = contents;
                // convertCSV();
            };
            reader.readAsText(file);
        };
        input.click();
    }
}

function loadCSV() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    input.onchange = function (e) {
        const file = e.target.files[0];
        // console.log(file["name"]);
        // let fileName=file["name"];
        let tempArr = file["name"].split(".");
        tempArr.pop();
        document.getElementById("table-name").value = tempArr.join(".");
        const reader = new FileReader();
        reader.onload = function (event) {
            let contents = event.target.result.trim();
            document.getElementById('csv-input').value = contents;
            convertCSV();
        };
        reader.readAsText(file);
    };
    input.click();
}

function addEventListenersToSaveAndCopyTextButtons() {
    let saveTextButtons = document.getElementsByClassName("saveTextByIDButton");
    let copyTextButtons = document.getElementsByClassName("copyTextByIDButton");
    for (let i = 0; i < saveTextButtons.length; i++) {
        saveTextButtons[i].addEventListener("click", saveTextValueByID)
    }
    for (let i = 0; i < copyTextButtons.length; i++) {
        copyTextButtons[i].addEventListener("click", copyTextValueByID)
    }
}

function saveTextValueByID(evt) {
    let id = evt.target.id.split("-")[0];
    console.log(id);
    let contents = document.getElementById(id).value;
    saveToFile(contents, "results", ".csv", true);
}

function copyTextValueByID(evt) {
    let id = evt.target.id.split("-")[0];
    console.log(id);
    let contents = document.getElementById(id).value;
    copyToClipboard(contents);
}

function copyToClipboard(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
    alert("Content copied to clipboard:\n" + text);
}

function saveToFile(content, filename, suffix, useDate = "false") {
    const date = new Date().toISOString().split('T')[0];
    const blob = new Blob([content], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    if (useDate) {
        link.download = `${filename}-${date}${suffix}`;
    }
    else {
        link.download = `${filename}${suffix}`;
    }
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function showTableInputForm() {
    clearTableInputForm();
    document.getElementById('table-input-form').style.display = "flex";
    document.getElementById('middle-section').style.display = "none";
    document.getElementById('top-section').style.display = "none";
}

function saveTable() {
    if (document.getElementById("output").innerText.trim() === "") {
        alert("There is nothing to save.");
    }
    else {
        let name = document.getElementById('table-name').value;
        if (confirm("This will overwrite " + name + ".  Are you sure?")) {
            let table = {};
            //get name
            // let name = document.getElementById('table-name').value;
            //get csv input
            let csvInput = document.getElementById('csv-input').value.trim();
            let csvArrays = csvToArrays(csvInput);
            //get headers
            let headers = csvArrays.shift();
            //get data
            let data = csvArrays;
            //get dataTypes
            //loop through checkboxes
            let dataTypes = [];
            for (let i = 0; i < headers.length; i++) {
                let dataType = "STRING";
                let id = 'cell-0-' + i.toString();
                let thisCheckbox = document.getElementById(id);
                if (thisCheckbox.style.color === "green") {
                    dataType = "NUMBER";
                }
                dataTypes.push(dataType);
            }
            table["name"] = name;
            table["headers"] = headers;
            table["data"] = data;
            table["dataTypes"] = dataTypes;
            console.log(table);
            database["tables"][name] = JSON.parse(JSON.stringify(table));
            console.log(database);
            refreshDataTablesOnLeft();
            document.getElementById('table-input-form').style.display = "none";
            document.getElementById('middle-section').style.display = "flex";
            document.getElementById('top-section').style.display = "flex";
        }
    }
}

function refreshDataTablesOnLeft() {
    // alert("refresh called");
    removeEventListenersToEditAndDeleteButtons();
    let tableNames = Object.keys(database["tables"]);
    let str = "";
    for (let i = 0; i < tableNames.length; i++) {
        // console.log(tableNames[i]);
        str += tableObjectToHTMLTable(database["tables"][tableNames[i]], true, false);
        // str+="<hr>";
    }
    document.getElementById("left-side").innerHTML = str;
    addEventListenersToEditAndDeleteButtons();
}

function addEventListenersToEditAndDeleteButtons() {
    let editButtons = document.getElementsByClassName('edit-button');
    let deleteButtons = document.getElementsByClassName('delete-button');
    let toggleButtons = document.getElementsByClassName('toggle-button');
    for (let i = 0; i < editButtons.length; i++) {
        editButtons[i].addEventListener("click", editTable);
    }
    for (let i = 0; i < deleteButtons.length; i++) {
        deleteButtons[i].addEventListener("click", deleteTable);
    }
    for (let i = 0; i < toggleButtons.length; i++) {
        toggleButtons[i].addEventListener("click", toggleTable);
    }
}

function editTable(evt) {
    let id = evt.target.id.split("-")[0];
    console.log(id);
    //open the form
    showTableInputForm();
    //convert array of arrays to csv
    let contents = tableObjectToCSV(database["tables"][id]);
    document.getElementById("csv-input").value = contents;
    //fill in the filename
    document.getElementById("table-name").value = id;
    //make preview table
    convertCSV();
    //fill in the datatype green text
    turnFormTableHeadersGreen(id);
}

function turnFormTableHeadersGreen(tableName) {
    let dataTypes = database["tables"][tableName]["dataTypes"];
    for (let i = 0; i < dataTypes.length; i++) {
        let cellId = "cell-0-" + i.toString();
        if (dataTypes[i] === "NUMBER") {
            document.getElementById(cellId).style.color = "green";
        }
    }
}

function deleteTable(evt) {
    if (confirm("This will delete the table.  Are you sure?")) {
        let id = evt.target.id.split("-")[0];
        console.log(id);
        delete database["tables"][id];
        refreshDataTablesOnLeft();
    }
}

function removeEventListenersToEditAndDeleteButtons() {
    let editButtons = document.getElementsByClassName('edit-button');
    let deleteButtons = document.getElementsByClassName('delete-button');
    let toggleButtons = document.getElementsByClassName('toggle-button');
    for (let i = 0; i < editButtons.length; i++) {
        editButtons[i].removeEventListener("click", editTable);
    }
    for (let i = 0; i < deleteButtons.length; i++) {
        deleteButtons[i].removeEventListener("click", deleteTable);
    }
    for (let i = 0; i < toggleButtons.length; i++) {
        toggleButtons[i].removeEventListener("click", toggleTable);
    }
}

function toggleTable(evt) {
    console.log(evt.target.id);
    let id = evt.target.id.split("-")[0] + "-preview-table";
    let thisTable = document.getElementById(id);
    console.log(id);
    console.log("style.display=", thisTable.style.display);
    if ((thisTable.style.display === "") || (thisTable.style.display === "table")) {
        thisTable.style.display = "none";
    }
    else {
        thisTable.style.display = "table";
    }
}

function convertCSV() {
    revmoveEventListenersFromTableHeaders();
    let csvInput = document.getElementById('csv-input').value.trim();
    console.log(csvInput);
    let tableName = document.getElementById('table-name').value;
    // console.log(tableNameIsValid(tableName));
    console.log(isValidCSV(csvInput));
    // if ((tableNameIsValid(tableName) === "true") && (isValidCSV(csvInput) === "true")) {
    if ((true) && (isValidCSV(csvInput) === "true")) {
        let arrayData = csvToArrays(csvInput);
        console.log(arrayData);
        //check for spaces in headers
        if (checkForSpacesoInArrayOneDim(arrayData[0])) {
            alert("There are spaces in the column headers, please adjust.");
            document.getElementById('output').innerHTML = "";
            return;
        }
        else if (needsTrimmedOneDim(arrayData[0])) {
            alert("Column headers need trimmed, please adjust.")
            document.getElementById('output').innerHTML = "";
            return;
        }
        else if (hasDuplicatesOneDim(arrayData[0])) {
            alert("Headers contain duplicates, please adjust.")
            document.getElementById('output').innerHTML = "";
            return;
        }
        else if (invalidCharactersInHeaders(arrayData[0])) {
            alert("Headers contain invalid characters, please adjust.");
            document.getElementById('output').innerHTML = "";
            return;
        }
        //check for duplicate headers
        console.log(arrayData);
        let tableHTML = arrayToTableForm(arrayData, tableName, false);
        document.getElementById('output').innerHTML = tableHTML;
        addEventListenersToTableHeaders();
        // document.getElementById('saveTable').style.display="revert";
    }
    else {
        // if (tableNameIsValid(tableName) !== "true") {
        //     alert(tableNameIsValid(tableName));
        //     document.getElementById('output').innerHTML = "";
        //     return;
        // }
        if (isValidCSV(csvInput) !== "true") {
            document.getElementById('output').innerHTML = "";
            alert(isValidCSV(csvInput));
            return;
        }
    }
}

function needsTrimmedOneDim(arr) {
    let result = false;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== arr[i].trim()) {
            result = true;
        }
    }
    return result;
}

function checkForSpacesoInArrayOneDim(arr) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].indexOf(" ") !== -1) {
            return true;
        }
    }
    return false;
}

function invalidCharactersInHeaders(arr) {
    // for (let i = 0; i < arr.length; i++) {
    //     if (arr[i].indexOf(" ") !==-1) {
    //         return true;
    //     }
    // }
    //need to regex the character set
    return false;
}

function hasDuplicatesOneDim(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j]) {
                return true;
            }
        }
    }
    return false;
}

function tableNameIsValid(tableName) {
    if (tableName.trim() === "") {
        return "There is no table name listed.";
    }
    else if (Object.keys(database["tables"]).indexOf(tableName) !== -1) {
        return "There is already a table with this name, please rename.";
    }
    else if (tableName.indexOf("`") !== -1) {
        return "The table name cannot contain backticks ` ."
    }
    else {
        return "true";
    }
}

function isValidCSV(csv) {
    if (csv.trim() === "") {
        return "The CSV is empty.";
    }
    else {
        //Not working right
        //I suggest parsing the csv with my parsing then checking the cells
        // const lines = csv.split('\n');
        // const columnCount = lines[0].split(',').length;

        // for (let line of lines) {
        //     const cells = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
        //     if (cells.length !== columnCount) {
        //         return "The CSV Columns are not equal.";
        //     }
        //     for (let cell of cells) {
        //         if (cell.includes('"')) {
        //             if (!cell.startsWith('"') || !cell.endsWith('"') || cell.slice(1, -1).includes('"')) {
        //                 return "There are improper double quotes in cells.";
        //             }
        //         }
        //     }
        // }
        console.log("got to true");
        return "true";
    }
}

function tableObjectToCSV(table) {
    let csv = "";
    csv += table["headers"].join(",") + "\n";
    csv += arraysToCSV(table["data"]);
    return csv;
}

function arrayToTableForm(arrayData, tableName, noGreenToggle = false, limitLengthTo100 = true) {
    let htmlTable = `<h2>${tableName}</h2><table>`;
    if (noGreenToggle === false) {
        htmlTable += `<h3>Click the header to indicate the column is numeric.</h3>`;
    }
    //htmlTable += `<h3>Click the header to indicate the column is numeric.</h3>`;
    let limit = arrayData.length;
    if (limitLengthTo100) {
        if (limit > 100) {
            limit = 100;
        }
    }
    for (let i = 0; i < limit; i++) {
        htmlTable += '<tr>';
        for (let j = 0; j < arrayData[i].length; j++) {
            if (i === 0) {
                //htmlTable += `<th id="cell-${i}-${j}"><input type="checkbox" id="checkbox-${i}-${j}"> ${arrayData[i][j]}</th>`;
                if (noGreenToggle === false) {
                    htmlTable += `<th id="cell-${i}-${j}" class="green-if-numeric">${arrayData[i][j]}</th>`;
                }
                else {
                    htmlTable += `<th id="cell-${i}-${j}">${arrayData[i][j]}</th>`;
                }

            } else {
                htmlTable += `<td id="cell-${i}-${j}">${arrayData[i][j]}</td>`;
            }
        }
        htmlTable += '</tr>';
    }
    htmlTable += '</table>';
    return htmlTable;
}

function addEventListenersToTableHeaders() {
    let headers = document.getElementsByClassName("green-if-numeric");
    for (let i = 0; i < headers.length; i++) {
        headers[i].addEventListener("click", toggleGreen);
    }
}

function revmoveEventListenersFromTableHeaders() {
    let headers = document.getElementsByClassName("green-if-numeric");
    for (let i = 0; i < headers.length; i++) {
        headers[i].removeEventListener("click", toggleGreen);
    }
}

function toggleGreen(evt) {
    console.log(evt.target);
    console.log(evt.target.id);
    console.log(this);
    let thisElement = document.getElementById(evt.target.id);
    if (thisElement.style.color === "green") {
        thisElement.style.color = "revert";
    }
    else {
        thisElement.style.color = "green";
    }
}

function tableObjectToHTMLTable(tableObject, includeButtons = true, showAll = false) {
    // console.log(tableObject);
    let tableName = tableObject["name"];
    let headers = tableObject["headers"];
    let data = tableObject["data"];
    let dataTypes = tableObject["dataTypes"];
    let stopIndex = data.length;
    if (stopIndex > 10) {
        stopIndex = 10;
    }
    if (showAll) {
        stopIndex = data.length;
    }
    let htmlTable = "";
    if (includeButtons) {
        htmlTable += `<nav><button  class='edit-button' id='${tableName}-edit-button'>Edit</button><button class='delete-button' id='${tableName}-delete-button'>Delete</button><button class='toggle-button' id='${tableName}-toggle-button'>Show/Hide</button></nav>`;
    }
    if (includeButtons) {
        htmlTable += `<table id='${tableName}-preview-table' style='display:none;'>`;
    }
    else {
        htmlTable += `<table id='${tableName}-preview-table'>`;
    }

    for (let i = 0; i < headers.length; i++) {
        if (dataTypes[i] === "NUMBER") {
            htmlTable += `<th class="color-green">${headers[i]}</th>`
        }
        else {
            htmlTable += `<th>${headers[i]}</th>`
        }

    }
    for (let i = 0; i < stopIndex; i++) {
        htmlTable += '<tr>';
        for (let j = 0; j < data[i].length; j++) {
            htmlTable += `<td>${data[i][j]}</td>`;
        }
        htmlTable += '</tr>';
    }
    htmlTable += '</table></div>';
    if (includeButtons) {
        htmlTable = `<div class='fixed-size-scroll'><h2>${tableName}</h2>` + htmlTable;
    }
    else {
        htmlTable = `<div class='fixed-size-scroll'><h2>${tableName}</h2>Number of Records: ${data.length}` + htmlTable;
    }
    return htmlTable;
}
</script>
<script>
let tradewinds = { "tables": { "Suppliers": { "name": "Suppliers", "headers": ["SupplierID", "SupplierName", "ContactName", "Address", "City", "PostalCode", "Country", "Phone"], "data": [["1", "Exotic Liquid", "Charlotte Cooper", "49 Gilbert St.", "Londona", "EC1 4SD", "UK", "(171) 555-2222"], ["2", "New Orleans Cajun Delights", "Shelley Burke", "P.O. Box 78934", "New Orleans", "70117", "USA", "(100) 555-4822"], ["3", "Grandma Kelly's Homestead", "Regina Murphy", "707 Oxford Rd.", "Ann Arbor", "48104", "USA", "(313) 555-5735"], ["4", "Tokyo Traders", "Yoshi Nagase", "9-8 Sekimai Musashino-shi", "Tokyo", "100", "Japan", "(03) 3555-5011"], ["5", "Cooperativa de Quesos 'Las Cabras'", "Antonio del Valle Saavedra ", "Calle del Rosal 4", "Oviedo", "33007", "Spain", "(98) 598 76 54"], ["6", "Mayumi's", "Mayumi Ohno", "92 Setsuko Chuo-ku", "Osaka", "545", "Japan", "(06) 431-7877"], ["7", "Pavlova, Ltd.", "Ian Devling", "74 Rose St. Moonie Ponds", "Melbourne", "3058", "Australia", "(03) 444-2343"], ["8", "Specialty Biscuits, Ltd.", "Peter Wilson", "29 King's Way", "Manchester", "M14 GSD", "UK", "(161) 555-4448"], ["9", "PB KnÃ¤ckebrÃ¶d AB", "Lars Peterson", "Kaloadagatan 13", "GÃ¶teborg", "S-345 67", "Sweden ", "031-987 65 43"], ["10", "Refrescos Americanas LTDA", "Carlos Diaz", "Av. das Americanas 12.890", "SÃ£o Paulo", "5442", "Brazil", "(11) 555 4640"], ["11", "Heli SÃ¼Ãwaren GmbH & Co. KG", "Petra Winkler", "TiergartenstraÃe 5", "Berlin", "10785", "Germany", "(010) 9984510"], ["12", "Plutzer LebensmittelgroÃmÃ¤rkte AG", "Martin Bein", "Bogenallee 51", "Frankfurt", "60439", "Germany", "(069) 992755"], ["13", "Nord-Ost-Fisch Handelsgesellschaft mbH", "Sven Petersen", "Frahmredder 112a", "Cuxhaven", "27478", "Germany", "(04721) 8713"], ["14", "Formaggi Fortini s.r.l.", "Elio Rossi", "Viale Dante, 75", "Ravenna", "48100", "Italy", "(0544) 60323"], ["15", "Norske Meierier", "Beate Vileid", "Hatlevegen 5", "Sandvika", "1320", "Norway", "(0)2-953010"], ["16", "Bigfoot Breweries", "Cheryl Saylor", "3400 - 8th Avenue Suite 210", "Bend", "97101", "USA", "(503) 555-9931"], ["17", "Svensk SjÃ¶fÃ¶da AB", "Michael BjÃ¶rn", "BrovallavÃ¤gen 231", "Stockholm", "S-123 45", "Sweden", "08-123 45 67"], ["18", "Aux joyeux ecclÃ©siastiques", "GuylÃ¨ne Nodier", "203, Rue des Francs-Bourgeois", "Paris", "75004", "France", "(1) 03.83.00.68"], ["19", "New England Seafood Cannery", "Robb Merchant", "Order Processing Dept. 2100 Paul Revere Blvd.", "Boston", "2134", "USA", "(617) 555-3267"], ["20", "Leka Trading", "Chandra Leka", "471 Serangoon Loop, Suite #402", "Singapore", "512", "Singapore", "555-8787"], ["21", "Lyngbysild", "Niels Petersen", "Lyngbysild Fiskebakken 10", "Lyngby", "2800", "Denmark", "43844108"], ["22", "Zaanse Snoepfabriek", "Dirk Luchte", "Verkoop Rijnweg 22", "Zaandam", "9999 ZZ", "Netherlands", "(12345) 1212"], ["23", "Karkki Oy", "Anne Heikkonen", "Valtakatu 12", "Lappeenranta", "53120", "Finland", "(953) 10956"], ["24", "G'day, Mate", "Wendy Mackenzie", "170 Prince Edward Parade Hunter's Hill", "Sydney", "2042", "Australia", "(02) 555-5914"], ["25", "Ma Maison", "Jean-Guy Lauzon", "2960 Rue St. Laurent", "MontrÃ©al", "H1J 1C3", "Canada", "(514) 555-9022"], ["26", "Pasta Buttini s.r.l.", "Giovanni Giudici", "Via dei Gelsomini, 153", "Salerno", "84100", "Italy", "(089) 6547665"], ["27", "Escargots Nouveaux", "Marie Delamare", "22, rue H. Voiron", "Montceau", "71300", "France", "85.57.00.07"], ["28", "Gai pÃ¢turage", "Eliane Noz", "Bat. B 3, rue des Alpes", "Annecy", "74000", "France", "38.76.98.06"], ["29", "ForÃªts d'Ã©rables", "Chantal Goulet", "148 rue Chasseur", "Ste-Hyacinthe", "J2S 7S8", "Canada", "(514) 555-2955"]], "dataTypes": ["NUMBER", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"] }, "Shippers": { "name": "Shippers", "headers": ["ShipperID", "ShipperName", "Phone"], "data": [["1", "Speedy Express", "(503) 555-9831"], ["2", "United Package", "(503) 555-3199"], ["3", "Federal Shipping", "(503) 555-9931"]], "dataTypes": ["NUMBER", "STRING", "STRING"] }, "Products": { "name": "Products", "headers": ["ProductID", "ProductName", "SupplierID", "CategoryID", "Unit", "Price"], "data": [["1", "Chais", "1", "1", "10 boxes x 20 bags", "18"], ["2", "Chang", "1", "1", "24 - 12 oz bottles", "19"], ["3", "Aniseed Syrup", "1", "2", "12 - 550 ml bottles", "10"], ["4", "Chef Anton's Cajun Seasoning", "2", "2", "48 - 6 oz jars", "22"], ["5", "Chef Anton's Gumbo Mix", "2", "2", "36 boxes", "21.35"], ["6", "Grandma's Boysenberry Spread", "3", "2", "12 - 8 oz jars", "25"], ["7", "Uncle Bob's Organic Dried Pears", "3", "7", "12 - 1 lb pkgs.", "30"], ["8", "Northwoods Cranberry Sauce", "3", "2", "12 - 12 oz jars", "40"], ["9", "Mishi Kobe Niku", "4", "6", "18 - 500 g pkgs.", "97"], ["10", "Ikura", "4", "8", "12 - 200 ml jars", "31"], ["11", "Queso Cabrales", "5", "4", "1 kg pkg.", "21"], ["12", "Queso Manchego La Pastora", "5", "4", "10 - 500 g pkgs.", "38"], ["13", "Konbu", "6", "8", "2 kg box", "6"], ["14", "Tofu", "6", "7", "40 - 100 g pkgs.", "23.25"], ["15", "Genen Shouyu", "6", "2", "24 - 250 ml bottles", "15.5"], ["16", "Pavlova", "7", "3", "32 - 500 g boxes", "17.45"], ["17", "Alice Mutton", "7", "6", "20 - 1 kg tins", "39"], ["18", "Carnarvon Tigers", "7", "8", "16 kg pkg.", "62.5"], ["19", "Teatime Chocolate Biscuits", "8", "3", "10 boxes x 12 pieces", "9.2"], ["20", "Sir Rodney's Marmalade", "8", "3", "30 gift boxes", "81"], ["21", "Sir Rodney's Scones", "8", "3", "24 pkgs. x 4 pieces", "10"], ["22", "Gustaf's KnÃ¤ckebrÃ¶d", "9", "5", "24 - 500 g pkgs.", "21"], ["23", "TunnbrÃ¶d", "9", "5", "12 - 250 g pkgs.", "9"], ["24", "GuaranÃ¡ FantÃ¡stica", "10", "1", "12 - 355 ml cans", "4.5"], ["25", "NuNuCa NuÃ-Nougat-Creme", "11", "3", "20 - 450 g glasses", "14"], ["26", "GumbÃ¤r GummibÃ¤rchen", "11", "3", "100 - 250 g bags", "31.23"], ["27", "Schoggi Schokolade", "11", "3", "100 - 100 g pieces", "43.9"], ["28", "RÃ¶ssle Sauerkraut", "12", "7", "25 - 825 g cans", "45.6"], ["29", "ThÃ¼ringer Rostbratwurst", "12", "6", "50 bags x 30 sausgs.", "123.79"], ["30", "Nord-Ost Matjeshering", "13", "8", "10 - 200 g glasses", "25.89"], ["31", "Gorgonzola Telino", "14", "4", "12 - 100 g pkgs", "12.5"], ["32", "Mascarpone Fabioli", "14", "4", "24 - 200 g pkgs.", "32"], ["33", "Geitost", "15", "4", "500 g", "2.5"], ["34", "Sasquatch Ale", "16", "1", "24 - 12 oz bottles", "14"], ["35", "Steeleye Stout", "16", "1", "24 - 12 oz bottles", "18"], ["36", "Inlagd Sill", "17", "8", "24 - 250 g jars", "19"], ["37", "Gravad lax", "17", "8", "12 - 500 g pkgs.", "26"], ["38", "CÃ´te de Blaye", "18", "1", "12 - 75 cl bottles", "263.5"], ["39", "Chartreuse verte", "18", "1", "750 cc per bottle", "18"], ["40", "Boston Crab Meat", "19", "8", "24 - 4 oz tins", "18.4"], ["41", "Jack's New England Clam Chowder", "19", "8", "12 - 12 oz cans", "9.65"], ["42", "Singaporean Hokkien Fried Mee", "20", "5", "32 - 1 kg pkgs.", "14"], ["43", "Ipoh Coffee", "20", "1", "16 - 500 g tins", "46"], ["44", "Gula Malacca", "20", "2", "20 - 2 kg bags", "19.45"], ["45", "RÃ¸gede sild", "21", "8", "1k pkg.", "9.5"], ["46", "Spegesild", "21", "8", "4 - 450 g glasses", "12"], ["47", "Zaanse koeken", "22", "3", "10 - 4 oz boxes", "9.5"], ["48", "Chocolade", "22", "3", "10 pkgs.", "12.75"], ["49", "Maxilaku", "23", "3", "24 - 50 g pkgs.", "20"], ["50", "Valkoinen suklaa", "23", "3", "12 - 100 g bars", "16.25"], ["51", "Manjimup Dried Apples", "24", "7", "50 - 300 g pkgs.", "53"], ["52", "Filo Mix", "24", "5", "16 - 2 kg boxes", "7"], ["53", "Perth Pasties", "24", "6", "48 pieces", "32.8"], ["54", "TourtiÃ¨re", "25", "6", "16 pies", "7.45"], ["55", "PÃ¢tÃ© chinois", "25", "6", "24 boxes x 2 pies", "24"], ["56", "Gnocchi di nonna Alice", "26", "5", "24 - 250 g pkgs.", "38"], ["57", "Ravioli Angelo", "26", "5", "24 - 250 g pkgs.", "19.5"], ["58", "Escargots de Bourgogne", "27", "8", "24 pieces", "13.25"], ["59", "Raclette Courdavault", "28", "4", "5 kg pkg.", "55"], ["60", "Camembert Pierrot", "28", "4", "15 - 300 g rounds", "34"], ["61", "Sirop d'Ã©rable", "29", "2", "24 - 500 ml bottles", "28.5"], ["62", "Tarte au sucre", "29", "3", "48 pies", "49.3"], ["63", "Vegie-spread", "7", "2", "15 - 625 g jars", "43.9"], ["64", "Wimmers gute SemmelknÃ¶del", "12", "5", "20 bags x 4 pieces", "33.25"], ["65", "Louisiana Fiery Hot Pepper Sauce", "2", "2", "32 - 8 oz bottles", "21.05"], ["66", "Louisiana Hot Spiced Okra", "2", "2", "24 - 8 oz jars", "17"], ["67", "Laughing Lumberjack Lager", "16", "1", "24 - 12 oz bottles", "14"], ["68", "Scottish Longbreads", "8", "3", "10 boxes x 8 pieces", "12.5"], ["69", "Gudbrandsdalsost", "15", "4", "10 kg pkg.", "36"], ["70", "Outback Lager", "7", "1", "24 - 355 ml bottles", "15"], ["71", "FlÃ¸temysost", "15", "4", "10 - 500 g pkgs.", "21.5"], ["72", "Mozzarella di Giovanni", "14", "4", "24 - 200 g pkgs.", "34.8"], ["73", "RÃ¶d Kaviar", "17", "8", "24 - 150 g jars", "15"], ["74", "Longlife Tofu", "4", "7", "5 kg pkg.", "10"], ["75", "RhÃ¶nbrÃ¤u Klosterbier", "12", "1", "24 - 0.5 l bottles", "7.75"], ["76", "LakkalikÃ¶Ã¶ri", "23", "1", "500 ml ", "18"], ["77", "Original Frankfurter grÃ¼ne SoÃe", "12", "2", "12 boxes", "13"]], "dataTypes": ["NUMBER", "STRING", "NUMBER", "NUMBER", "STRING", "NUMBER"] }, "OrderDetails": { "name": "OrderDetails", "headers": ["OrderDetailID", "OrderID", "ProductID", "Quantity"], "data": [["1", "10248", "11", "12"], ["2", "10248", "42", "10"], ["3", "10248", "72", "5"], ["4", "10249", "14", "9"], ["5", "10249", "51", "40"], ["6", "10250", "41", "10"], ["7", "10250", "51", "35"], ["8", "10250", "65", "15"], ["9", "10251", "22", "6"], ["10", "10251", "57", "15"], ["11", "10251", "65", "20"], ["12", "10252", "20", "40"], ["13", "10252", "33", "25"], ["14", "10252", "60", "40"], ["15", "10253", "31", "20"], ["16", "10253", "39", "42"], ["17", "10253", "49", "40"], ["18", "10254", "24", "15"], ["19", "10254", "55", "21"], ["20", "10254", "74", "21"], ["21", "10255", "2", "20"], ["22", "10255", "16", "35"], ["23", "10255", "36", "25"], ["24", "10255", "59", "30"], ["25", "10256", "53", "15"], ["26", "10256", "77", "12"], ["27", "10257", "27", "25"], ["28", "10257", "39", "6"], ["29", "10257", "77", "15"], ["30", "10258", "2", "50"], ["31", "10258", "5", "65"], ["32", "10258", "32", "6"], ["33", "10259", "21", "10"], ["34", "10259", "37", "1"], ["35", "10260", "41", "16"], ["36", "10260", "57", "50"], ["37", "10260", "62", "15"], ["38", "10260", "70", "21"], ["39", "10261", "21", "20"], ["40", "10261", "35", "20"], ["41", "10262", "5", "12"], ["42", "10262", "7", "15"], ["43", "10262", "56", "2"], ["44", "10263", "16", "60"], ["45", "10263", "24", "28"], ["46", "10263", "30", "60"], ["47", "10263", "74", "36"], ["48", "10264", "2", "35"], ["49", "10264", "41", "25"], ["50", "10265", "17", "30"], ["51", "10265", "70", "20"], ["52", "10266", "12", "12"], ["53", "10267", "40", "50"], ["54", "10267", "59", "70"], ["55", "10267", "76", "15"], ["56", "10268", "29", "10"], ["57", "10268", "72", "4"], ["58", "10269", "33", "60"], ["59", "10269", "72", "20"], ["60", "10270", "36", "30"], ["61", "10270", "43", "25"], ["62", "10271", "33", "24"], ["63", "10272", "20", "6"], ["64", "10272", "31", "40"], ["65", "10272", "72", "24"], ["66", "10273", "10", "24"], ["67", "10273", "31", "15"], ["68", "10273", "33", "20"], ["69", "10273", "40", "60"], ["70", "10273", "76", "33"], ["71", "10274", "71", "20"], ["72", "10274", "72", "7"], ["73", "10275", "24", "12"], ["74", "10275", "59", "6"], ["75", "10276", "10", "15"], ["76", "10276", "13", "10"], ["77", "10277", "28", "20"], ["78", "10277", "62", "12"], ["79", "10278", "44", "16"], ["80", "10278", "59", "15"], ["81", "10278", "63", "8"], ["82", "10278", "73", "25"], ["83", "10279", "17", "15"], ["84", "10280", "24", "12"], ["85", "10280", "55", "20"], ["86", "10280", "75", "30"], ["87", "10281", "19", "1"], ["88", "10281", "24", "6"], ["89", "10281", "35", "4"], ["90", "10282", "30", "6"], ["91", "10282", "57", "2"], ["92", "10283", "15", "20"], ["93", "10283", "19", "18"], ["94", "10283", "60", "35"], ["95", "10283", "72", "3"], ["96", "10284", "27", "15"], ["97", "10284", "44", "21"], ["98", "10284", "60", "20"], ["99", "10284", "67", "5"], ["100", "10285", "1", "45"], ["101", "10285", "40", "40"], ["102", "10285", "53", "36"], ["103", "10286", "35", "100"], ["104", "10286", "62", "40"], ["105", "10287", "16", "40"], ["106", "10287", "34", "20"], ["107", "10287", "46", "15"], ["108", "10288", "54", "10"], ["109", "10288", "68", "3"], ["110", "10289", "3", "30"], ["111", "10289", "64", "9"], ["112", "10290", "5", "20"], ["113", "10290", "29", "15"], ["114", "10290", "49", "15"], ["115", "10290", "77", "10"], ["116", "10291", "13", "20"], ["117", "10291", "44", "24"], ["118", "10291", "51", "2"], ["119", "10292", "20", "20"], ["120", "10293", "18", "12"], ["121", "10293", "24", "10"], ["122", "10293", "63", "5"], ["123", "10293", "75", "6"], ["124", "10294", "1", "18"], ["125", "10294", "17", "15"], ["126", "10294", "43", "15"], ["127", "10294", "60", "21"], ["128", "10294", "75", "6"], ["129", "10295", "56", "4"], ["130", "10296", "11", "12"], ["131", "10296", "16", "30"], ["132", "10296", "69", "15"], ["133", "10297", "39", "60"], ["134", "10297", "72", "20"], ["135", "10298", "2", "40"], ["136", "10298", "36", "40"], ["137", "10298", "59", "30"], ["138", "10298", "62", "15"], ["139", "10299", "19", "15"], ["140", "10299", "70", "20"], ["141", "10300", "66", "30"], ["142", "10300", "68", "20"], ["143", "10301", "40", "10"], ["144", "10301", "56", "20"], ["145", "10302", "17", "40"], ["146", "10302", "28", "28"], ["147", "10302", "43", "12"], ["148", "10303", "40", "40"], ["149", "10303", "65", "30"], ["150", "10303", "68", "15"], ["151", "10304", "49", "30"], ["152", "10304", "59", "10"], ["153", "10304", "71", "2"], ["154", "10305", "18", "25"], ["155", "10305", "29", "25"], ["156", "10305", "39", "30"], ["157", "10306", "30", "10"], ["158", "10306", "53", "10"], ["159", "10306", "54", "5"], ["160", "10307", "62", "10"], ["161", "10307", "68", "3"], ["162", "10308", "69", "1"], ["163", "10308", "70", "5"], ["164", "10309", "4", "20"], ["165", "10309", "6", "30"], ["166", "10309", "42", "2"], ["167", "10309", "43", "20"], ["168", "10309", "71", "3"], ["169", "10310", "16", "10"], ["170", "10310", "62", "5"], ["171", "10311", "42", "6"], ["172", "10311", "69", "7"], ["173", "10312", "28", "4"], ["174", "10312", "43", "24"], ["175", "10312", "53", "20"], ["176", "10312", "75", "10"], ["177", "10313", "36", "12"], ["178", "10314", "32", "40"], ["179", "10314", "58", "30"], ["180", "10314", "62", "25"], ["181", "10315", "34", "14"], ["182", "10315", "70", "30"], ["183", "10316", "41", "10"], ["184", "10316", "62", "70"], ["185", "10317", "1", "20"], ["186", "10318", "41", "20"], ["187", "10318", "76", "6"], ["188", "10319", "17", "8"], ["189", "10319", "28", "14"], ["190", "10319", "76", "30"], ["191", "10320", "71", "30"], ["192", "10321", "35", "10"], ["193", "10322", "52", "20"], ["194", "10323", "15", "5"], ["195", "10323", "25", "4"], ["196", "10323", "39", "4"], ["197", "10324", "16", "21"], ["198", "10324", "35", "70"], ["199", "10324", "46", "30"], ["200", "10324", "59", "40"], ["201", "10324", "63", "80"], ["202", "10325", "6", "6"], ["203", "10325", "13", "12"], ["204", "10325", "14", "9"], ["205", "10325", "31", "4"], ["206", "10325", "72", "40"], ["207", "10326", "4", "24"], ["208", "10326", "57", "16"], ["209", "10326", "75", "50"], ["210", "10327", "2", "25"], ["211", "10327", "11", "50"], ["212", "10327", "30", "35"], ["213", "10327", "58", "30"], ["214", "10328", "59", "9"], ["215", "10328", "65", "40"], ["216", "10328", "68", "10"], ["217", "10329", "19", "10"], ["218", "10329", "30", "8"], ["219", "10329", "38", "20"], ["220", "10329", "56", "12"], ["221", "10330", "26", "50"], ["222", "10330", "72", "25"], ["223", "10331", "54", "15"], ["224", "10332", "18", "40"], ["225", "10332", "42", "10"], ["226", "10332", "47", "16"], ["227", "10333", "14", "10"], ["228", "10333", "21", "10"], ["229", "10333", "71", "40"], ["230", "10334", "52", "8"], ["231", "10334", "68", "10"], ["232", "10335", "2", "7"], ["233", "10335", "31", "25"], ["234", "10335", "32", "6"], ["235", "10335", "51", "48"], ["236", "10336", "4", "18"], ["237", "10337", "23", "40"], ["238", "10337", "26", "24"], ["239", "10337", "36", "20"], ["240", "10337", "37", "28"], ["241", "10337", "72", "25"], ["242", "10338", "17", "20"], ["243", "10338", "30", "15"], ["244", "10339", "4", "10"], ["245", "10339", "17", "70"], ["246", "10339", "62", "28"], ["247", "10340", "18", "20"], ["248", "10340", "41", "12"], ["249", "10340", "43", "40"], ["250", "10341", "33", "8"], ["251", "10341", "59", "9"], ["252", "10342", "2", "24"], ["253", "10342", "31", "56"], ["254", "10342", "36", "40"], ["255", "10342", "55", "40"], ["256", "10343", "64", "50"], ["257", "10343", "68", "4"], ["258", "10343", "76", "15"], ["259", "10344", "4", "35"], ["260", "10344", "8", "70"], ["261", "10345", "8", "70"], ["262", "10345", "19", "80"], ["263", "10345", "42", "9"], ["264", "10346", "17", "36"], ["265", "10346", "56", "20"], ["266", "10347", "25", "10"], ["267", "10347", "39", "50"], ["268", "10347", "40", "4"], ["269", "10347", "75", "6"], ["270", "10348", "1", "15"], ["271", "10348", "23", "25"], ["272", "10349", "54", "24"], ["273", "10350", "50", "15"], ["274", "10350", "69", "18"], ["275", "10351", "38", "20"], ["276", "10351", "41", "13"], ["277", "10351", "44", "77"], ["278", "10351", "65", "10"], ["279", "10352", "24", "10"], ["280", "10352", "54", "20"], ["281", "10353", "11", "12"], ["282", "10353", "38", "50"], ["283", "10354", "1", "12"], ["284", "10354", "29", "4"], ["285", "10355", "24", "25"], ["286", "10355", "57", "25"], ["287", "10356", "31", "30"], ["288", "10356", "55", "12"], ["289", "10356", "69", "20"], ["290", "10357", "10", "30"], ["291", "10357", "26", "16"], ["292", "10357", "60", "8"], ["293", "10358", "24", "10"], ["294", "10358", "34", "10"], ["295", "10358", "36", "20"], ["296", "10359", "16", "56"], ["297", "10359", "31", "70"], ["298", "10359", "60", "80"], ["299", "10360", "28", "30"], ["300", "10360", "29", "35"], ["301", "10360", "38", "10"], ["302", "10360", "49", "35"], ["303", "10360", "54", "28"], ["304", "10361", "39", "54"], ["305", "10361", "60", "55"], ["306", "10362", "25", "50"], ["307", "10362", "51", "20"], ["308", "10362", "54", "24"], ["309", "10363", "31", "20"], ["310", "10363", "75", "12"], ["311", "10363", "76", "12"], ["312", "10364", "69", "30"], ["313", "10364", "71", "5"], ["314", "10365", "11", "24"], ["315", "10366", "65", "5"], ["316", "10366", "77", "5"], ["317", "10367", "34", "36"], ["318", "10367", "54", "18"], ["319", "10367", "65", "15"], ["320", "10367", "77", "7"], ["321", "10368", "21", "5"], ["322", "10368", "28", "13"], ["323", "10368", "57", "25"], ["324", "10368", "64", "35"], ["325", "10369", "29", "20"], ["326", "10369", "56", "18"], ["327", "10370", "1", "15"], ["328", "10370", "64", "30"], ["329", "10370", "74", "20"], ["330", "10371", "36", "6"], ["331", "10372", "20", "12"], ["332", "10372", "38", "40"], ["333", "10372", "60", "70"], ["334", "10372", "72", "42"], ["335", "10373", "58", "80"], ["336", "10373", "71", "50"], ["337", "10374", "31", "30"], ["338", "10374", "58", "15"], ["339", "10375", "14", "15"], ["340", "10375", "54", "10"], ["341", "10376", "31", "42"], ["342", "10377", "28", "20"], ["343", "10377", "39", "20"], ["344", "10378", "71", "6"], ["345", "10379", "41", "8"], ["346", "10379", "63", "16"], ["347", "10379", "65", "20"], ["348", "10380", "30", "18"], ["349", "10380", "53", "20"], ["350", "10380", "60", "6"], ["351", "10380", "70", "30"], ["352", "10381", "74", "14"], ["353", "10382", "5", "32"], ["354", "10382", "18", "9"], ["355", "10382", "29", "14"], ["356", "10382", "33", "60"], ["357", "10382", "74", "50"], ["358", "10383", "13", "20"], ["359", "10383", "50", "15"], ["360", "10383", "56", "20"], ["361", "10384", "20", "28"], ["362", "10384", "60", "15"], ["363", "10385", "7", "10"], ["364", "10385", "60", "20"], ["365", "10385", "68", "8"], ["366", "10386", "24", "15"], ["367", "10386", "34", "10"], ["368", "10387", "24", "15"], ["369", "10387", "28", "6"], ["370", "10387", "59", "12"], ["371", "10387", "71", "15"], ["372", "10388", "45", "15"], ["373", "10388", "52", "20"], ["374", "10388", "53", "40"], ["375", "10389", "10", "16"], ["376", "10389", "55", "15"], ["377", "10389", "62", "20"], ["378", "10389", "70", "30"], ["379", "10390", "31", "60"], ["380", "10390", "35", "40"], ["381", "10390", "46", "45"], ["382", "10390", "72", "24"], ["383", "10391", "13", "18"], ["384", "10392", "69", "50"], ["385", "10393", "2", "25"], ["386", "10393", "14", "42"], ["387", "10393", "25", "7"], ["388", "10393", "26", "70"], ["389", "10393", "31", "32"], ["390", "10394", "13", "10"], ["391", "10394", "62", "10"], ["392", "10395", "46", "28"], ["393", "10395", "53", "70"], ["394", "10395", "69", "8"], ["395", "10396", "23", "40"], ["396", "10396", "71", "60"], ["397", "10396", "72", "21"], ["398", "10397", "21", "10"], ["399", "10397", "51", "18"], ["400", "10398", "35", "30"], ["401", "10398", "55", "120"], ["402", "10399", "68", "60"], ["403", "10399", "71", "30"], ["404", "10399", "76", "35"], ["405", "10399", "77", "14"], ["406", "10400", "29", "21"], ["407", "10400", "35", "35"], ["408", "10400", "49", "30"], ["409", "10401", "30", "18"], ["410", "10401", "56", "70"], ["411", "10401", "65", "20"], ["412", "10401", "71", "60"], ["413", "10402", "23", "60"], ["414", "10402", "63", "65"], ["415", "10403", "16", "21"], ["416", "10403", "48", "70"], ["417", "10404", "26", "30"], ["418", "10404", "42", "40"], ["419", "10404", "49", "30"], ["420", "10405", "3", "50"], ["421", "10406", "1", "10"], ["422", "10406", "21", "30"], ["423", "10406", "28", "42"], ["424", "10406", "36", "5"], ["425", "10406", "40", "2"], ["426", "10407", "11", "30"], ["427", "10407", "69", "15"], ["428", "10407", "71", "15"], ["429", "10408", "37", "10"], ["430", "10408", "54", "6"], ["431", "10408", "62", "35"], ["432", "10409", "14", "12"], ["433", "10409", "21", "12"], ["434", "10410", "33", "49"], ["435", "10410", "59", "16"], ["436", "10411", "41", "25"], ["437", "10411", "44", "40"], ["438", "10411", "59", "9"], ["439", "10412", "14", "20"], ["440", "10413", "1", "24"], ["441", "10413", "62", "40"], ["442", "10413", "76", "14"], ["443", "10414", "19", "18"], ["444", "10414", "33", "50"], ["445", "10415", "17", "2"], ["446", "10415", "33", "20"], ["447", "10416", "19", "20"], ["448", "10416", "53", "10"], ["449", "10416", "57", "20"], ["450", "10417", "38", "50"], ["451", "10417", "46", "2"], ["452", "10417", "68", "36"], ["453", "10417", "77", "35"], ["454", "10418", "2", "60"], ["455", "10418", "47", "55"], ["456", "10418", "61", "16"], ["457", "10418", "74", "15"], ["458", "10419", "60", "60"], ["459", "10419", "69", "20"], ["460", "10420", "9", "20"], ["461", "10420", "13", "2"], ["462", "10420", "70", "8"], ["463", "10420", "73", "20"], ["464", "10421", "19", "4"], ["465", "10421", "26", "30"], ["466", "10421", "53", "15"], ["467", "10421", "77", "10"], ["468", "10422", "26", "2"], ["469", "10423", "31", "14"], ["470", "10423", "59", "20"], ["471", "10424", "35", "60"], ["472", "10424", "38", "49"], ["473", "10424", "68", "30"], ["474", "10425", "55", "10"], ["475", "10425", "76", "20"], ["476", "10426", "56", "5"], ["477", "10426", "64", "7"], ["478", "10427", "14", "35"], ["479", "10428", "46", "20"], ["480", "10429", "50", "40"], ["481", "10429", "63", "35"], ["482", "10430", "17", "45"], ["483", "10430", "21", "50"], ["484", "10430", "56", "30"], ["485", "10430", "59", "70"], ["486", "10431", "17", "50"], ["487", "10431", "40", "50"], ["488", "10431", "47", "30"], ["489", "10432", "26", "10"], ["490", "10432", "54", "40"], ["491", "10433", "56", "28"], ["492", "10434", "11", "6"], ["493", "10434", "76", "18"], ["494", "10435", "2", "10"], ["495", "10435", "22", "12"], ["496", "10435", "72", "10"], ["497", "10436", "46", "5"], ["498", "10436", "56", "40"], ["499", "10436", "64", "30"], ["500", "10436", "75", "24"], ["501", "10437", "53", "15"], ["502", "10438", "19", "15"], ["503", "10438", "34", "20"], ["504", "10438", "57", "15"], ["505", "10439", "12", "15"], ["506", "10439", "16", "16"], ["507", "10439", "64", "6"], ["508", "10439", "74", "30"], ["509", "10440", "2", "45"], ["510", "10440", "16", "49"], ["511", "10440", "29", "24"], ["512", "10440", "61", "90"], ["513", "10441", "27", "50"], ["514", "10442", "11", "30"], ["515", "10442", "54", "80"], ["516", "10442", "66", "60"], ["517", "10443", "11", "6"], ["518", "10443", "28", "12"]], "dataTypes": ["NUMBER", "NUMBER", "NUMBER", "NUMBER"] }, "Employees": { "name": "Employees", "headers": ["EmployeeID", "LastName", "FirstName", "BirthDate", "Photo", "Notes"], "data": [["1", "Davolio", "Nancy", "1968-12-08", "EmpID1.pic", "Education includes a BA in psychology from Colorado State University. She also completed (The Art of the Cold Call). Nancy is a member of 'Toastmasters International'."], ["2", "Fuller", "Andrew", "1952-02-19", "EmpID2.pic", "Andrew received his BTS commercial and a Ph.D. in international marketing from the University of Dallas. He is fluent in French and Italian and reads German. He joined the company as a sales representative, was promoted to sales manager and was then named vice president of sales. Andrew is a member of the Sales Management Roundtable, the Seattle Chamber of Commerce, and the Pacific Rim Importers Association."], ["3", "Leverling", "Janet", "1963-08-30", "EmpID3.pic", "Janet has a BS degree in chemistry from Boston College). She has also completed a certificate program in food retailing management. Janet was hired as a sales associate and was promoted to sales representative."], ["4", "Peacock", "Margaret", "1958-09-19", "EmpID4.pic", "Margaret holds a BA in English literature from Concordia College and an MA from the American Institute of Culinary Arts. She was temporarily assigned to the London office before returning to her permanent post in Seattle."], ["5", "Buchanan", "Steven", "1955-03-04", "EmpID5.pic", "Steven Buchanan graduated from St. Andrews University, Scotland, with a BSC degree. Upon joining the company as a sales representative, he spent 6 months in an orientation program at the Seattle office and then returned to his permanent post in London, where he was promoted to sales manager. Mr. Buchanan has completed the courses 'Successful Telemarketing' and 'International Sales Management'. He is fluent in French."], ["6", "Suyama", "Michael", "1963-07-02", "EmpID6.pic", "Michael is a graduate of Sussex University (MA, economics) and the University of California at Los Angeles (MBA, marketing). He has also taken the courses 'Multi-Cultural Selling' and 'Time Management for the Sales Professional'. He is fluent in Japanese and can read and write French, Portuguese, and Spanish."], ["7", "King", "Robert", "1960-05-29", "EmpID7.pic", "Robert King served in the Peace Corps and traveled extensively before completing his degree in English at the University of Michigan and then joining the company. After completing a course entitled 'Selling in Europe', he was transferred to the London office."], ["8", "Callahan", "Laura", "1958-01-09", "EmpID8.pic", "Laura received a BA in psychology from the University of Washington. She has also completed a course in business French. She reads and writes French."], ["9", "Dodsworth", "Anne", "1969-07-02", "EmpID9.pic", "Anne has a BA degree in English from St. Lawrence College. She is fluent in French and German."], ["10", "West", "Adam", "1928-09-19", "EmpID10.pic", "An old chum"]], "dataTypes": ["NUMBER", "STRING", "STRING", "STRING", "STRING", "STRING"] }, "Customers": { "name": "Customers", "headers": ["CustomerID", "CustomerName", "ContactName", "Address", "City", "PostalCode", "Country"], "data": [["1", "Alfreds Futterkiste", "Maria Anders", "Obere Str. 57", "Berlin", "12209", "Germany"], ["2", "Ana Trujillo Emparedados y helados", "Ana Trujillo", "Avda. de la ConstituciÃ³n 2222", "MÃ©xico D.F.", "5021", "Mexico"], ["3", "Antonio Moreno TaquerÃ­a", "Antonio Moreno", "Mataderos 2312", "MÃ©xico D.F.", "5023", "Mexico"], ["4", "Around the Horn", "Thomas Hardy", "120 Hanover Sq.", "London", "WA1 1DP", "UK"], ["5", "Berglunds snabbkÃ¶p", "Christina Berglund", "BerguvsvÃ¤gen 8", "LuleÃ¥", "S-958 22", "Sweden"], ["6", "Blauer See Delikatessen", "Hanna Moos", "Forsterstr. 57", "Mannheim", "68306", "Germany"], ["7", "Blondel pÃ¨re et fils", "FrÃ©dÃ©rique Citeaux", "24, place KlÃ©ber", "Strasbourg", "67000", "France"], ["8", "BÃ³lido Comidas preparadas", "MartÃ­n Sommer", "C/ Araquil, 67", "Madrid", "28023", "Spain"], ["9", "Bon app'", "Laurence Lebihans", "12, rue des Bouchers", "Marseille", "13008", "France"], ["10", "Bottom-Dollar Marketse", "Elizabeth Lincoln", "23 Tsawassen Blvd.", "Tsawassen", "T2F 8M4", "Canada"], ["11", "B's Beverages", "Victoria Ashworth", "Fauntleroy Circus", "London", "EC2 5NT", "UK"], ["12", "Cactus Comidas para llevar", "Patricio Simpson", "Cerrito 333", "Buenos Aires", "1010", "Argentina"], ["13", "Centro comercial Moctezuma", "Francisco Chang", "Sierras de Granada 9993", "MÃ©xico D.F.", "5022", "Mexico"], ["14", "Chop-suey Chinese", "Yang Wang", "Hauptstr. 29", "Bern", "3012", "Switzerland"], ["15", "ComÃ©rcio Mineiro", "Pedro Afonso", "Av. dos LusÃ­adas, 23", "SÃ£o Paulo", "05432-043", "Brazil"], ["16", "Consolidated Holdings", "Elizabeth Brown", "Berkeley Gardens 12 Brewery ", "London", "WX1 6LT", "UK"], ["17", "Drachenblut Delikatessend", "Sven Ottlieb", "Walserweg 21", "Aachen", "52066", "Germany"], ["18", "Du monde entier", "Janine Labrune", "67, rue des Cinquante Otages", "Nantes", "44000", "France"], ["19", "Eastern Connection", "Ann Devon", "35 King George", "London", "WX3 6FW", "UK"], ["20", "Ernst Handel", "Roland Mendel", "Kirchgasse 6", "Graz", "8010", "Austria"], ["21", "Familia Arquibaldo", "Aria Cruz", "Rua OrÃ³s, 92", "SÃ£o Paulo", "05442-030", "Brazil"], ["22", "FISSA Fabrica Inter. Salchichas S.A.", "Diego Roel", "C/ Moralzarzal, 86", "Madrid", "28034", "Spain"], ["23", "Folies gourmandes", "Martine RancÃ©", "184, chaussÃ©e de Tournai", "Lille", "59000", "France"], ["24", "Folk och fÃ¤ HB", "Maria Larsson", "Ãkergatan 24", "BrÃ¤cke", "S-844 67", "Sweden"], ["25", "Frankenversand", "Peter Franken", "Berliner Platz 43", "MÃ¼nchen", "80805", "Germany"], ["26", "France restauration", "Carine Schmitt", "54, rue Royale", "Nantes", "44000", "France"], ["27", "Franchi S.p.A.", "Paolo Accorti", "Via Monte Bianco 34", "Torino", "10100", "Italy"], ["28", "Furia Bacalhau e Frutos do Mar", "Lino Rodriguez ", "Jardim das rosas n. 32", "Lisboa", "1675", "Portugal"], ["29", "GalerÃ­a del gastrÃ³nomo", "Eduardo Saavedra", "Rambla de CataluÃ±a, 23", "Barcelona", "8022", "Spain"], ["30", "Godos Cocina TÃ­pica", "JosÃ© Pedro Freyre", "C/ Romero, 33", "Sevilla", "41101", "Spain"], ["31", "Gourmet Lanchonetes", "AndrÃ© Fonseca", "Av. Brasil, 442", "Campinas", "04876-786", "Brazil"], ["32", "Great Lakes Food Market", "Howard Snyder", "2732 Baker Blvd.", "Eugene", "97403", "USA"], ["33", "GROSELLA-Restaurante", "Manuel Pereira", "5Âª Ave. Los Palos Grandes", "Caracas", "1081", "Venezuela"], ["34", "Hanari Carnes", "Mario Pontes", "Rua do PaÃ§o, 67", "Rio de Janeiro", "05454-876", "Brazil"], ["35", "HILARIÃN-Abastos", "Carlos HernÃ¡ndez", "Carrera 22 con Ave. Carlos Soublette #8-35", "San CristÃ³bal", "5022", "Venezuela"], ["36", "Hungry Coyote Import Store", "Yoshi Latimer", "City Center Plaza 516 Main St.", "Elgin", "97827", "USA"], ["37", "Hungry Owl All-Night Grocers", "Patricia McKenna", "8 Johnstown Road", "Cork", "", "Ireland"], ["38", "Island Trading", "Helen Bennett", "Garden House Crowther Way", "Cowes", "PO31 7PJ", "UK"], ["39", "KÃ¶niglich Essen", "Philip Cramer", "Maubelstr. 90", "Brandenburg", "14776", "Germany"], ["40", "La corne d'abondance", "Daniel Tonini", "67, avenue de l'Europe", "Versailles", "78000", "France"], ["41", "La maison d'Asie", "Annette Roulet", "1 rue Alsace-Lorraine", "Toulouse", "31000", "France"], ["42", "Laughing Bacchus Wine Cellars", "Yoshi Tannamuri", "1900 Oak St.", "Vancouver", "V3F 2K1", "Canada"], ["43", "Lazy K Kountry Store", "John Steel", "12 Orchestra Terrace", "Walla Walla", "99362", "USA"], ["44", "Lehmanns Marktstand", "Renate Messner", "Magazinweg 7", "Frankfurt a.M. ", "60528", "Germany"], ["45", "Let's Stop N Shop", "Jaime Yorres", "87 Polk St. Suite 5", "San Francisco", "94117", "USA"], ["46", "LILA-Supermercado", "Carlos GonzÃ¡lez", "Carrera 52 con Ave. BolÃ­var #65-98 Llano Largo", "Barquisimeto", "3508", "Venezuela"], ["47", "LINO-Delicateses", "Felipe Izquierdo", "Ave. 5 de Mayo Porlamar", "I. de Margarita", "4980", "Venezuela"], ["48", "Lonesome Pine Restaurant", "Fran Wilson", "89 Chiaroscuro Rd.", "Portland", "97219", "USA"], ["49", "Magazzini Alimentari Riuniti", "Giovanni Rovelli", "Via Ludovico il Moro 22", "Bergamo", "24100", "Italy"], ["50", "Maison Dewey", "Catherine Dewey", "Rue Joseph-Bens 532", "Bruxelles", "B-1180", "Belgium"], ["51", "MÃ¨re Paillarde", "Jean FresniÃ¨re", "43 rue St. Laurent", "MontrÃ©al", "H1J 1C3", "Canada"], ["52", "Morgenstern Gesundkost", "Alexander Feuer", "Heerstr. 22", "Leipzig", "4179", "Germany"], ["53", "North/South", "Simon Crowther", "South House 300 Queensbridge", "London", "SW7 1RZ", "UK"], ["54", "OcÃ©ano AtlÃ¡ntico Ltda.", "Yvonne Moncada", "Ing. Gustavo Moncada 8585 Piso 20-A", "Buenos Aires", "1010", "Argentina"], ["55", "Old World Delicatessen", "Rene Phillips", "2743 Bering St.", "Anchorage", "99508", "USA"], ["56", "Ottilies KÃ¤seladen", "Henriette Pfalzheim", "Mehrheimerstr. 369", "KÃ¶ln", "50739", "Germany"], ["57", "Paris spÃ©cialitÃ©s", "Marie Bertrand", "265, boulevard Charonne", "Paris", "75012", "France"], ["58", "Pericles Comidas clÃ¡sicas", "Guillermo FernÃ¡ndez", "Calle Dr. Jorge Cash 321", "MÃ©xico D.F.", "5033", "Mexico"], ["59", "Piccolo und mehr", "Georg Pipps", "Geislweg 14", "Salzburg", "5020", "Austria"], ["60", "Princesa Isabel Vinhoss", "Isabel de Castro", "Estrada da saÃºde n. 58", "Lisboa", "1756", "Portugal"], ["61", "Que DelÃ­cia", "Bernardo Batista", "Rua da Panificadora, 12", "Rio de Janeiro", "02389-673", "Brazil"], ["62", "Queen Cozinha", "LÃºcia Carvalho", "Alameda dos CanÃ rios, 891", "SÃ£o Paulo", "05487-020", "Brazil"], ["63", "QUICK-Stop", "Horst Kloss", "TaucherstraÃe 10", "Cunewalde", "1307", "Germany"], ["64", "Rancho grande", "Sergio GutiÃ©rrez", "Av. del Libertador 900", "Buenos Aires", "1010", "Argentina"], ["65", "Rattlesnake Canyon Grocery", "Paula Wilson", "2817 Milton Dr.", "Albuquerque", "87110", "USA"], ["66", "Reggiani Caseifici", "Maurizio Moroni", "Strada Provinciale 124", "Reggio Emilia", "42100", "Italy"], ["67", "Ricardo Adocicados", "Janete Limeira", "Av. Copacabana, 267", "Rio de Janeiro", "02389-890", "Brazil"], ["68", "Richter Supermarkt", "Michael Holz", "Grenzacherweg 237", "GenÃ¨ve", "1203", "Switzerland"], ["69", "Romero y tomillo", "Alejandra Camino", "Gran VÃ­a, 1", "Madrid", "28001", "Spain"], ["70", "SantÃ© Gourmet", "Jonas Bergulfsen", "Erling Skakkes gate 78", "Stavern", "4110", "Norway"], ["71", "Save-a-lot Markets", "Jose Pavarotti", "187 Suffolk Ln.", "Boise", "83720", "USA"], ["72", "Seven Seas Imports", "Hari Kumar", "90 Wadhurst Rd.", "London", "OX15 4NB", "UK"], ["73", "Simons bistro", "Jytte Petersen", "VinbÃ¦ltet 34", "KÃ¸benhavn", "1734", "Denmark"], ["74", "SpÃ©cialitÃ©s du monde", "Dominique Perrier", "25, rue Lauriston", "Paris", "75016", "France"], ["75", "Split Rail Beer & Ale", "Art Braunschweiger", "P.O. Box 555", "Lander", "82520", "USA"], ["76", "SuprÃªmes dÃ©lices", "Pascale Cartrain", "Boulevard Tirou, 255", "Charleroi", "B-6000", "Belgium"], ["77", "The Big Cheese", "Liz Nixon", "89 Jefferson Way Suite 2", "Portland", "97201", "USA"], ["78", "The Cracker Box", "Liu Wong", "55 Grizzly Peak Rd.", "Butte", "59801", "USA"], ["79", "Toms SpezialitÃ¤ten", "Karin Josephs", "Luisenstr. 48", "MÃ¼nster", "44087", "Germany"], ["80", "Tortuga Restaurante", "Miguel Angel Paolino", "Avda. Azteca 123", "MÃ©xico D.F.", "5033", "Mexico"], ["81", "TradiÃ§Ã£o Hipermercados", "Anabela Domingues", "Av. InÃªs de Castro, 414", "SÃ£o Paulo", "05634-030", "Brazil"], ["82", "Trail's Head Gourmet Provisioners", "Helvetius Nagy", "722 DaVinci Blvd.", "Kirkland", "98034", "USA"], ["83", "Vaffeljernet", "Palle Ibsen", "SmagslÃ¸get 45", "Ãrhus", "8200", "Denmark"], ["84", "Victuailles en stock", "Mary Saveley", "2, rue du Commerce", "Lyon", "69004", "France"], ["85", "Vins et alcools Chevalier", "Paul Henriot", "59 rue de l'Abbaye", "Reims", "51100", "France"], ["86", "Die Wandernde Kuh", "Rita MÃ¼ller", "Adenauerallee 900", "Stuttgart", "70563", "Germany"], ["87", "Wartian Herkku", "Pirkko Koskitalo", "Torikatu 38", "Oulu", "90110", "Finland"], ["88", "Wellington Importadora", "Paula Parente", "Rua do Mercado, 12", "Resende", "08737-363", "Brazil"], ["89", "White Clover Markets", "Karl Jablonski", "305 - 14th Ave. S. Suite 3B", "Seattle", "98128", "USA"], ["90", "Wilman Kala", "Matti Karttunen", "Keskuskatu 45", "Helsinki", "21240", "Finland"], ["91", "Wolski", "Zbyszek", "ul. Filtrowa 68", "Walla", "01-012", "Poland"]], "dataTypes": ["NUMBER", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"] }, "Categories": { "name": "Categories", "headers": ["CategoryID", "CategoryName", "Description"], "data": [["1", "Beverages", "Soft drinks, coffees, teas, beers, and ales"], ["2", "Condiments", "Sweet and savory sauces, relishes, spreads, and seasonings"], ["3", "Confections", "Desserts, candies, and sweet breads"], ["4", "Dairy Products", "Cheeses"], ["5", "Grains/Cereals", "Breads, crackers, pasta, and cereal"], ["6", "Meat/Poultry", "Prepared meats"], ["7", "Produce", "Dried fruit and bean curd"], ["8", "Seafood", "Seaweed and fish"]], "dataTypes": ["NUMBER", "STRING", "STRING"] }, "Orders": { "name": "Orders", "headers": ["OrderID", "CustomerID", "EmployeeID", "OrderDate", "ShipperID"], "data": [["10248", "90", "5", "1996-07-04", "3"], ["10249", "81", "6", "1996-07-05", "1"], ["10250", "34", "4", "1996-07-08", "2"], ["10251", "84", "3", "1996-07-08", "1"], ["10252", "76", "4", "1996-07-09", "2"], ["10253", "34", "3", "1996-07-10", "2"], ["10254", "14", "5", "1996-07-11", "2"], ["10255", "68", "9", "1996-07-12", "3"], ["10256", "88", "3", "1996-07-15", "2"], ["10257", "35", "4", "1996-07-16", "3"], ["10258", "20", "1", "1996-07-17", "1"], ["10259", "13", "4", "1996-07-18", "3"], ["10260", "55", "4", "1996-07-19", "1"], ["10261", "61", "4", "1996-07-19", "2"], ["10262", "65", "8", "1996-07-22", "3"], ["10263", "20", "9", "1996-07-23", "3"], ["10264", "24", "6", "1996-07-24", "3"], ["10265", "7", "2", "1996-07-25", "1"], ["10266", "87", "3", "1996-07-26", "3"], ["10267", "25", "4", "1996-07-29", "1"], ["10268", "33", "8", "1996-07-30", "3"], ["10269", "89", "5", "1996-07-31", "1"], ["10270", "87", "1", "1996-08-01", "1"], ["10271", "75", "6", "1996-08-01", "2"], ["10272", "65", "6", "1996-08-02", "2"], ["10273", "63", "3", "1996-08-05", "3"], ["10274", "85", "6", "1996-08-06", "1"], ["10275", "49", "1", "1996-08-07", "1"], ["10276", "80", "8", "1996-08-08", "3"], ["10277", "52", "2", "1996-08-09", "3"], ["10278", "5", "8", "1996-08-12", "2"], ["10279", "44", "8", "1996-08-13", "2"], ["10280", "5", "2", "1996-08-14", "1"], ["10281", "69", "4", "1996-08-14", "1"], ["10282", "69", "4", "1996-08-15", "1"], ["10283", "46", "3", "1996-08-16", "3"], ["10284", "44", "4", "1996-08-19", "1"], ["10285", "63", "1", "1996-08-20", "2"], ["10286", "63", "8", "1996-08-21", "3"], ["10287", "67", "8", "1996-08-22", "3"], ["10288", "66", "4", "1996-08-23", "1"], ["10289", "11", "7", "1996-08-26", "3"], ["10290", "15", "8", "1996-08-27", "1"], ["10291", "61", "6", "1996-08-27", "2"], ["10292", "81", "1", "1996-08-28", "2"], ["10293", "80", "1", "1996-08-29", "3"], ["10294", "65", "4", "1996-08-30", "2"], ["10295", "85", "2", "1996-09-02", "2"], ["10296", "46", "6", "1996-09-03", "1"], ["10297", "7", "5", "1996-09-04", "2"], ["10298", "37", "6", "1996-09-05", "2"], ["10299", "67", "4", "1996-09-06", "2"], ["10300", "49", "2", "1996-09-09", "2"], ["10301", "86", "8", "1996-09-09", "2"], ["10302", "76", "4", "1996-09-10", "2"], ["10303", "30", "7", "1996-09-11", "2"], ["10304", "80", "1", "1996-09-12", "2"], ["10305", "55", "8", "1996-09-13", "3"], ["10306", "69", "1", "1996-09-16", "3"], ["10307", "48", "2", "1996-09-17", "2"], ["10308", "2", "7", "1996-09-18", "3"], ["10309", "37", "3", "1996-09-19", "1"], ["10310", "77", "8", "1996-09-20", "2"], ["10311", "18", "1", "1996-09-20", "3"], ["10312", "86", "2", "1996-09-23", "2"], ["10313", "63", "2", "1996-09-24", "2"], ["10314", "65", "1", "1996-09-25", "2"], ["10315", "38", "4", "1996-09-26", "2"], ["10316", "65", "1", "1996-09-27", "3"], ["10317", "48", "6", "1996-09-30", "1"], ["10318", "38", "8", "1996-10-01", "2"], ["10319", "80", "7", "1996-10-02", "3"], ["10320", "87", "5", "1996-10-03", "3"], ["10321", "38", "3", "1996-10-03", "2"], ["10322", "58", "7", "1996-10-04", "3"], ["10323", "39", "4", "1996-10-07", "1"], ["10324", "71", "9", "1996-10-08", "1"], ["10325", "39", "1", "1996-10-09", "3"], ["10326", "8", "4", "1996-10-10", "2"], ["10327", "24", "2", "1996-10-11", "1"], ["10328", "28", "4", "1996-10-14", "3"], ["10329", "75", "4", "1996-10-15", "2"], ["10330", "46", "3", "1996-10-16", "1"], ["10331", "9", "9", "1996-10-16", "1"], ["10332", "51", "3", "1996-10-17", "2"], ["10333", "87", "5", "1996-10-18", "3"], ["10334", "84", "8", "1996-10-21", "2"], ["10335", "37", "7", "1996-10-22", "2"], ["10336", "60", "7", "1996-10-23", "2"], ["10337", "25", "4", "1996-10-24", "3"], ["10338", "55", "4", "1996-10-25", "3"], ["10339", "51", "2", "1996-10-28", "2"], ["10340", "9", "1", "1996-10-29", "3"], ["10341", "73", "7", "1996-10-29", "3"], ["10342", "25", "4", "1996-10-30", "2"], ["10343", "44", "4", "1996-10-31", "1"], ["10344", "89", "4", "1996-11-01", "2"], ["10345", "63", "2", "1996-11-04", "2"], ["10346", "65", "3", "1996-11-05", "3"], ["10347", "21", "4", "1996-11-06", "3"], ["10348", "86", "4", "1996-11-07", "2"], ["10349", "75", "7", "1996-11-08", "1"], ["10350", "41", "6", "1996-11-11", "2"], ["10351", "20", "1", "1996-11-11", "1"], ["10352", "28", "3", "1996-11-12", "3"], ["10353", "59", "7", "1996-11-13", "3"], ["10354", "58", "8", "1996-11-14", "3"], ["10355", "4", "6", "1996-11-15", "1"], ["10356", "86", "6", "1996-11-18", "2"], ["10357", "46", "1", "1996-11-19", "3"], ["10358", "41", "5", "1996-11-20", "1"], ["10359", "72", "5", "1996-11-21", "3"], ["10360", "7", "4", "1996-11-22", "3"], ["10361", "63", "1", "1996-11-22", "2"], ["10362", "9", "3", "1996-11-25", "1"], ["10363", "17", "4", "1996-11-26", "3"], ["10364", "19", "1", "1996-11-26", "1"], ["10365", "3", "3", "1996-11-27", "2"], ["10366", "29", "8", "1996-11-28", "2"], ["10367", "83", "7", "1996-11-28", "3"], ["10368", "20", "2", "1996-11-29", "2"], ["10369", "75", "8", "1996-12-02", "2"], ["10370", "14", "6", "1996-12-03", "2"], ["10371", "41", "1", "1996-12-03", "1"], ["10372", "62", "5", "1996-12-04", "2"], ["10373", "37", "4", "1996-12-05", "3"], ["10374", "91", "1", "1996-12-05", "3"], ["10375", "36", "3", "1996-12-06", "2"], ["10376", "51", "1", "1996-12-09", "2"], ["10377", "72", "1", "1996-12-09", "3"], ["10378", "24", "5", "1996-12-10", "3"], ["10379", "61", "2", "1996-12-11", "1"], ["10380", "37", "8", "1996-12-12", "3"], ["10381", "46", "3", "1996-12-12", "3"], ["10382", "20", "4", "1996-12-13", "1"], ["10383", "4", "8", "1996-12-16", "3"], ["10384", "5", "3", "1996-12-16", "3"], ["10385", "75", "1", "1996-12-17", "2"], ["10386", "21", "9", "1996-12-18", "3"], ["10387", "70", "1", "1996-12-18", "2"], ["10388", "72", "2", "1996-12-19", "1"], ["10389", "10", "4", "1996-12-20", "2"], ["10390", "20", "6", "1996-12-23", "1"], ["10391", "17", "3", "1996-12-23", "3"], ["10392", "59", "2", "1996-12-24", "3"], ["10393", "71", "1", "1996-12-25", "3"], ["10394", "36", "1", "1996-12-25", "3"], ["10395", "35", "6", "1996-12-26", "1"], ["10396", "25", "1", "1996-12-27", "3"], ["10397", "60", "5", "1996-12-27", "1"], ["10398", "71", "2", "1996-12-30", "3"], ["10399", "83", "8", "1996-12-31", "3"], ["10400", "19", "1", "1997-01-01", "3"], ["10401", "65", "1", "1997-01-01", "1"], ["10402", "20", "8", "1997-01-02", "2"], ["10403", "20", "4", "1997-01-03", "3"], ["10404", "49", "2", "1997-01-03", "1"], ["10405", "47", "1", "1997-01-06", "1"], ["10406", "62", "7", "1997-01-07", "1"], ["10407", "56", "2", "1997-01-07", "2"], ["10408", "23", "8", "1997-01-08", "1"], ["10409", "54", "3", "1997-01-09", "1"], ["10410", "10", "3", "1997-01-10", "3"], ["10411", "10", "9", "1997-01-10", "3"], ["10412", "87", "8", "1997-01-13", "2"], ["10413", "41", "3", "1997-01-14", "2"], ["10414", "21", "2", "1997-01-14", "3"], ["10415", "36", "3", "1997-01-15", "1"], ["10416", "87", "8", "1997-01-16", "3"], ["10417", "73", "4", "1997-01-16", "3"], ["10418", "63", "4", "1997-01-17", "1"], ["10419", "68", "4", "1997-01-20", "2"], ["10420", "88", "3", "1997-01-21", "1"], ["10421", "61", "8", "1997-01-21", "1"], ["10422", "27", "2", "1997-01-22", "1"], ["10423", "31", "6", "1997-01-23", "3"], ["10424", "51", "7", "1997-01-23", "2"], ["10425", "41", "6", "1997-01-24", "2"], ["10426", "29", "4", "1997-01-27", "1"], ["10427", "59", "4", "1997-01-27", "2"], ["10428", "66", "7", "1997-01-28", "1"], ["10429", "37", "3", "1997-01-29", "2"], ["10430", "20", "4", "1997-01-30", "1"], ["10431", "10", "4", "1997-01-30", "2"], ["10432", "75", "3", "1997-01-31", "2"], ["10433", "60", "3", "1997-02-03", "3"], ["10434", "24", "3", "1997-02-03", "2"], ["10435", "16", "8", "1997-02-04", "2"], ["10436", "7", "3", "1997-02-05", "2"], ["10437", "87", "8", "1997-02-05", "1"], ["10438", "79", "3", "1997-02-06", "2"], ["10439", "51", "6", "1997-02-07", "3"], ["10440", "71", "4", "1997-02-10", "2"], ["10441", "55", "3", "1997-02-10", "2"], ["10442", "20", "3", "1997-02-11", "2"], ["10443", "66", "8", "1997-02-12", "1"], ["10444", "5", "3", "1997-02-12", "3"], ["10445", "5", "3", "1997-02-13", "1"], ["10446", "79", "6", "1997-02-14", "1"], ["10447", "67", "4", "1997-02-14", "2"], ["10448", "64", "4", "1997-02-17", "2"], ["10449", "7", "3", "1997-02-18", "2"], ["10450", "84", "8", "1997-02-19", "2"], ["10451", "63", "4", "1997-02-19", "3"], ["10452", "71", "8", "1997-02-20", "1"], ["10453", "4", "1", "1997-02-21", "2"], ["10454", "41", "4", "1997-02-21", "3"], ["10455", "87", "8", "1997-02-24", "2"], ["10456", "39", "8", "1997-02-25", "2"], ["10457", "39", "2", "1997-02-25", "1"], ["10458", "76", "7", "1997-02-26", "3"], ["10459", "84", "4", "1997-02-27", "2"], ["10460", "24", "8", "1997-02-28", "1"], ["10461", "46", "1", "1997-02-28", "3"], ["10462", "16", "2", "1997-03-03", "1"], ["10463", "76", "5", "1997-03-04", "3"], ["10464", "28", "4", "1997-03-04", "2"], ["10465", "83", "1", "1997-03-05", "3"], ["10466", "15", "4", "1997-03-06", "1"], ["10467", "49", "8", "1997-03-06", "2"], ["10468", "39", "3", "1997-03-07", "3"], ["10469", "89", "1", "1997-03-10", "1"], ["10470", "9", "4", "1997-03-11", "2"], ["10471", "11", "2", "1997-03-11", "3"], ["10472", "72", "8", "1997-03-12", "1"], ["10473", "38", "1", "1997-03-13", "3"], ["10474", "58", "5", "1997-03-13", "2"], ["10475", "76", "9", "1997-03-14", "1"], ["10476", "35", "8", "1997-03-17", "3"], ["10477", "60", "5", "1997-03-17", "2"], ["10478", "84", "2", "1997-03-18", "3"], ["10479", "65", "3", "1997-03-19", "3"], ["10480", "23", "6", "1997-03-20", "2"], ["10481", "67", "8", "1997-03-20", "2"], ["10482", "43", "1", "1997-03-21", "3"], ["10483", "89", "7", "1997-03-24", "2"], ["10484", "11", "3", "1997-03-24", "3"], ["10485", "47", "4", "1997-03-25", "2"], ["10486", "35", "1", "1997-03-26", "2"], ["10487", "62", "2", "1997-03-26", "2"], ["10488", "25", "8", "1997-03-27", "2"], ["10489", "59", "6", "1997-03-28", "2"], ["10490", "35", "7", "1997-03-31", "2"], ["10491", "28", "8", "1997-03-31", "3"], ["10492", "10", "3", "1997-04-01", "1"], ["10493", "41", "4", "1997-04-02", "3"], ["10494", "15", "4", "1997-04-02", "2"], ["10495", "42", "3", "1997-04-03", "3"], ["10496", "81", "7", "1997-04-04", "2"], ["10497", "44", "7", "1997-04-04", "1"], ["10498", "35", "8", "1997-04-07", "2"], ["10499", "46", "4", "1997-04-08", "2"], ["10500", "41", "6", "1997-04-09", "1"], ["10501", "6", "9", "1997-04-09", "3"], ["10502", "58", "2", "1997-04-10", "1"], ["10503", "37", "6", "1997-04-11", "2"], ["10504", "89", "4", "1997-04-11", "3"], ["10505", "51", "3", "1997-04-14", "3"], ["10506", "39", "9", "1997-04-15", "2"], ["10507", "3", "7", "1997-04-15", "1"], ["10508", "56", "1", "1997-04-16", "2"], ["10509", "6", "4", "1997-04-17", "1"], ["10510", "71", "6", "1997-04-18", "3"], ["10511", "9", "4", "1997-04-18", "3"], ["10512", "21", "7", "1997-04-21", "2"], ["10513", "86", "7", "1997-04-22", "1"], ["10514", "20", "3", "1997-04-22", "2"], ["10515", "63", "2", "1997-04-23", "1"], ["10516", "37", "2", "1997-04-24", "3"], ["10517", "53", "3", "1997-04-24", "3"], ["10518", "80", "4", "1997-04-25", "2"], ["10519", "14", "6", "1997-04-28", "3"], ["10520", "70", "7", "1997-04-29", "1"], ["10521", "12", "8", "1997-04-29", "2"], ["10522", "44", "4", "1997-04-30", "1"], ["10523", "72", "7", "1997-05-01", "2"], ["10524", "5", "1", "1997-05-01", "2"], ["10525", "9", "1", "1997-05-02", "2"], ["10526", "87", "4", "1997-05-05", "2"], ["10527", "63", "7", "1997-05-05", "1"], ["10528", "32", "6", "1997-05-06", "2"], ["10529", "50", "5", "1997-05-07", "2"], ["10530", "59", "3", "1997-05-08", "2"], ["10531", "54", "7", "1997-05-08", "1"], ["10532", "19", "7", "1997-05-09", "3"], ["10533", "24", "8", "1997-05-12", "1"], ["10534", "44", "8", "1997-05-12", "2"], ["10535", "3", "4", "1997-05-13", "1"], ["10536", "44", "3", "1997-05-14", "2"], ["10537", "68", "1", "1997-05-14", "1"], ["10538", "11", "9", "1997-05-15", "3"], ["10539", "11", "6", "1997-05-16", "3"], ["10540", "63", "3", "1997-05-19", "3"], ["10541", "34", "2", "1997-05-19", "1"], ["10542", "39", "1", "1997-05-20", "3"], ["10543", "46", "8", "1997-05-21", "2"], ["10544", "48", "4", "1997-05-21", "1"], ["10545", "43", "8", "1997-05-22", "2"], ["10546", "84", "1", "1997-05-23", "3"], ["10547", "72", "3", "1997-05-23", "2"], ["10548", "79", "3", "1997-05-26", "2"], ["10549", "63", "5", "1997-05-27", "1"], ["10550", "30", "7", "1997-05-28", "3"], ["10551", "28", "4", "1997-05-28", "3"], ["10552", "35", "2", "1997-05-29", "1"], ["10553", "87", "2", "1997-05-30", "2"], ["10554", "56", "4", "1997-05-30", "3"], ["10555", "71", "6", "1997-06-02", "3"], ["10556", "73", "2", "1997-06-03", "1"], ["10557", "44", "9", "1997-06-03", "2"], ["10558", "4", "1", "1997-06-04", "2"], ["10559", "7", "6", "1997-06-05", "1"], ["10560", "25", "8", "1997-06-06", "1"], ["10561", "24", "2", "1997-06-06", "2"], ["10562", "66", "1", "1997-06-09", "1"], ["10563", "67", "2", "1997-06-10", "2"], ["10564", "65", "4", "1997-06-10", "3"], ["10565", "51", "8", "1997-06-11", "2"], ["10566", "7", "9", "1997-06-12", "1"], ["10567", "37", "1", "1997-06-12", "1"], ["10568", "29", "3", "1997-06-13", "3"], ["10569", "65", "5", "1997-06-16", "1"], ["10570", "51", "3", "1997-06-17", "3"], ["10571", "20", "8", "1997-06-17", "3"], ["10572", "5", "3", "1997-06-18", "2"], ["10573", "3", "7", "1997-06-19", "3"], ["10574", "82", "4", "1997-06-19", "2"], ["10575", "52", "5", "1997-06-20", "1"], ["10576", "80", "3", "1997-06-23", "3"], ["10577", "82", "9", "1997-06-23", "2"], ["10578", "11", "4", "1997-06-24", "3"], ["10579", "45", "1", "1997-06-25", "2"], ["10580", "56", "4", "1997-06-26", "3"], ["10581", "21", "3", "1997-06-26", "1"], ["10582", "6", "3", "1997-06-27", "2"], ["10583", "87", "2", "1997-06-30", "2"], ["10584", "7", "4", "1997-06-30", "1"], ["10585", "88", "7", "1997-07-01", "1"], ["10586", "66", "9", "1997-07-02", "1"], ["10587", "61", "1", "1997-07-02", "1"], ["10588", "63", "2", "1997-07-03", "3"], ["10589", "32", "8", "1997-07-04", "2"], ["10590", "51", "4", "1997-07-07", "3"], ["10591", "83", "1", "1997-07-07", "1"], ["10592", "44", "3", "1997-07-08", "1"], ["10593", "44", "7", "1997-07-09", "2"], ["10594", "55", "3", "1997-07-09", "2"], ["10595", "20", "2", "1997-07-10", "1"], ["10596", "89", "8", "1997-07-11", "1"], ["10597", "59", "7", "1997-07-11", "3"], ["10598", "65", "1", "1997-07-14", "3"], ["10599", "11", "6", "1997-07-15", "3"], ["10600", "36", "4", "1997-07-16", "1"], ["10601", "35", "7", "1997-07-16", "1"], ["10602", "83", "8", "1997-07-17", "2"], ["10603", "71", "8", "1997-07-18", "2"], ["10604", "28", "1", "1997-07-18", "1"], ["10605", "51", "1", "1997-07-21", "2"], ["10606", "81", "4", "1997-07-22", "3"], ["10607", "71", "5", "1997-07-22", "1"], ["10608", "79", "4", "1997-07-23", "2"], ["10609", "18", "7", "1997-07-24", "2"], ["10610", "41", "8", "1997-07-25", "1"], ["10611", "91", "6", "1997-07-25", "2"], ["10612", "71", "1", "1997-07-28", "2"], ["10613", "35", "4", "1997-07-29", "2"], ["10614", "6", "8", "1997-07-29", "3"], ["10615", "90", "2", "1997-07-30", "3"], ["10616", "32", "1", "1997-07-31", "2"], ["10617", "32", "4", "1997-07-31", "2"], ["10618", "51", "1", "1997-08-01", "1"], ["10619", "51", "3", "1997-08-04", "3"], ["10620", "42", "2", "1997-08-05", "3"], ["10621", "38", "4", "1997-08-05", "2"], ["10622", "67", "4", "1997-08-06", "3"], ["10623", "25", "8", "1997-08-07", "2"], ["10624", "78", "4", "1997-08-07", "2"], ["10625", "2", "3", "1997-08-08", "1"], ["10626", "5", "1", "1997-08-11", "2"], ["10627", "71", "8", "1997-08-11", "3"], ["10628", "7", "4", "1997-08-12", "3"], ["10629", "30", "4", "1997-08-12", "3"], ["10630", "39", "1", "1997-08-13", "2"], ["10631", "41", "8", "1997-08-14", "1"], ["10632", "86", "8", "1997-08-14", "1"], ["10633", "20", "7", "1997-08-15", "3"], ["10634", "23", "4", "1997-08-15", "3"], ["10635", "49", "8", "1997-08-18", "3"], ["10636", "87", "4", "1997-08-19", "1"], ["10637", "62", "6", "1997-08-19", "1"], ["10638", "47", "3", "1997-08-20", "1"], ["10639", "70", "7", "1997-08-20", "3"], ["10640", "86", "4", "1997-08-21", "1"], ["10641", "35", "4", "1997-08-22", "2"], ["10642", "73", "7", "1997-08-22", "3"], ["10643", "1", "6", "1997-08-25", "1"], ["10644", "88", "3", "1997-08-25", "2"], ["10645", "34", "4", "1997-08-26", "1"], ["10646", "37", "9", "1997-08-27", "3"], ["10647", "61", "4", "1997-08-27", "2"], ["10648", "67", "5", "1997-08-28", "2"], ["10649", "50", "5", "1997-08-28", "3"], ["10650", "21", "5", "1997-08-29", "3"], ["10651", "86", "8", "1997-09-01", "2"], ["10652", "31", "4", "1997-09-01", "2"], ["10653", "25", "1", "1997-09-02", "1"], ["10654", "5", "5", "1997-09-02", "1"], ["10655", "66", "1", "1997-09-03", "2"], ["10656", "32", "6", "1997-09-04", "1"], ["10657", "71", "2", "1997-09-04", "2"], ["10658", "63", "4", "1997-09-05", "1"], ["10659", "62", "7", "1997-09-05", "2"], ["10660", "36", "8", "1997-09-08", "1"], ["10661", "37", "7", "1997-09-09", "3"], ["10662", "48", "3", "1997-09-09", "2"], ["10663", "9", "2", "1997-09-10", "2"], ["10664", "28", "1", "1997-09-10", "3"], ["10665", "48", "1", "1997-09-11", "2"], ["10666", "68", "7", "1997-09-12", "2"], ["10667", "20", "7", "1997-09-12", "1"], ["10668", "86", "1", "1997-09-15", "2"], ["10669", "73", "2", "1997-09-15", "1"], ["10670", "25", "4", "1997-09-16", "1"], ["10671", "26", "1", "1997-09-17", "1"], ["10672", "5", "9", "1997-09-17", "2"], ["10673", "90", "2", "1997-09-18", "1"], ["10674", "38", "4", "1997-09-18", "2"], ["10675", "25", "5", "1997-09-19", "2"], ["10676", "80", "2", "1997-09-22", "2"], ["10677", "3", "1", "1997-09-22", "3"], ["10678", "71", "7", "1997-09-23", "3"], ["10679", "7", "8", "1997-09-23", "3"], ["10680", "55", "1", "1997-09-24", "1"], ["10681", "32", "3", "1997-09-25", "3"], ["10682", "3", "3", "1997-09-25", "2"], ["10683", "18", "2", "1997-09-26", "1"], ["10684", "56", "3", "1997-09-26", "1"], ["10685", "31", "4", "1997-09-29", "2"], ["10686", "59", "2", "1997-09-30", "1"], ["10687", "37", "9", "1997-09-30", "2"], ["10688", "83", "4", "1997-10-01", "2"], ["10689", "5", "1", "1997-10-01", "2"], ["10690", "34", "1", "1997-10-02", "1"], ["10691", "63", "2", "1997-10-03", "2"], ["10692", "1", "4", "1997-10-03", "2"], ["10693", "89", "3", "1997-10-06", "3"], ["10694", "63", "8", "1997-10-06", "3"], ["10695", "90", "7", "1997-10-07", "1"], ["10696", "89", "8", "1997-10-08", "3"], ["10697", "47", "3", "1997-10-08", "1"], ["10698", "20", "4", "1997-10-09", "1"], ["10699", "52", "3", "1997-10-09", "3"], ["10700", "71", "3", "1997-10-10", "1"], ["10701", "37", "6", "1997-10-13", "3"], ["10702", "1", "4", "1997-10-13", "1"], ["10703", "24", "6", "1997-10-14", "2"], ["10704", "62", "6", "1997-10-14", "1"], ["10705", "35", "9", "1997-10-15", "2"], ["10706", "55", "8", "1997-10-16", "3"], ["10707", "4", "4", "1997-10-16", "3"], ["10708", "77", "6", "1997-10-17", "2"], ["10709", "31", "1", "1997-10-17", "3"], ["10710", "27", "1", "1997-10-20", "1"], ["10711", "71", "5", "1997-10-21", "2"], ["10712", "37", "3", "1997-10-21", "1"], ["10713", "71", "1", "1997-10-22", "1"], ["10714", "71", "5", "1997-10-22", "3"], ["10715", "9", "3", "1997-10-23", "1"], ["10716", "64", "4", "1997-10-24", "2"], ["10717", "25", "1", "1997-10-24", "2"], ["10718", "39", "1", "1997-10-27", "3"], ["10719", "45", "8", "1997-10-27", "2"], ["10720", "61", "8", "1997-10-28", "2"], ["10721", "63", "5", "1997-10-29", "3"], ["10722", "71", "8", "1997-10-29", "1"], ["10723", "89", "3", "1997-10-30", "1"], ["10724", "51", "8", "1997-10-30", "2"], ["10725", "21", "4", "1997-10-31", "3"], ["10726", "19", "4", "1997-11-03", "1"], ["10727", "66", "2", "1997-11-03", "1"], ["10728", "62", "4", "1997-11-04", "2"], ["10729", "47", "8", "1997-11-04", "3"], ["10730", "9", "5", "1997-11-05", "1"], ["10731", "14", "7", "1997-11-06", "1"], ["10732", "9", "3", "1997-11-06", "1"], ["10733", "5", "1", "1997-11-07", "3"], ["10734", "31", "2", "1997-11-07", "3"], ["10735", "45", "6", "1997-11-10", "2"], ["10736", "37", "9", "1997-11-11", "2"], ["10737", "85", "2", "1997-11-11", "2"], ["10738", "74", "2", "1997-11-12", "1"], ["10739", "85", "3", "1997-11-12", "3"], ["10740", "89", "4", "1997-11-13", "2"], ["10741", "4", "4", "1997-11-14", "3"], ["10742", "10", "3", "1997-11-14", "3"], ["10743", "4", "1", "1997-11-17", "2"], ["10744", "83", "6", "1997-11-17", "1"], ["10745", "63", "9", "1997-11-18", "1"], ["10746", "14", "1", "1997-11-19", "3"], ["10747", "59", "6", "1997-11-19", "1"], ["10748", "71", "3", "1997-11-20", "1"], ["10749", "38", "4", "1997-11-20", "2"], ["10750", "87", "9", "1997-11-21", "1"], ["10751", "68", "3", "1997-11-24", "3"], ["10752", "53", "2", "1997-11-24", "3"], ["10753", "27", "3", "1997-11-25", "1"], ["10754", "49", "6", "1997-11-25", "3"], ["10755", "9", "4", "1997-11-26", "2"], ["10756", "75", "8", "1997-11-27", "2"], ["10757", "71", "6", "1997-11-27", "1"], ["10758", "68", "3", "1997-11-28", "3"], ["10759", "2", "3", "1997-11-28", "3"], ["10760", "50", "4", "1997-12-01", "1"], ["10761", "65", "5", "1997-12-02", "2"], ["10762", "24", "3", "1997-12-02", "1"], ["10763", "23", "3", "1997-12-03", "3"], ["10764", "20", "6", "1997-12-03", "3"], ["10765", "63", "3", "1997-12-04", "3"], ["10766", "56", "4", "1997-12-05", "1"], ["10767", "76", "4", "1997-12-05", "3"], ["10768", "4", "3", "1997-12-08", "2"], ["10769", "83", "3", "1997-12-08", "1"], ["10770", "34", "8", "1997-12-09", "3"], ["10771", "20", "9", "1997-12-10", "2"], ["10772", "44", "3", "1997-12-10", "2"], ["10773", "20", "1", "1997-12-11", "3"], ["10774", "24", "4", "1997-12-11", "1"], ["10775", "78", "7", "1997-12-12", "1"], ["10776", "20", "1", "1997-12-15", "3"], ["10777", "31", "7", "1997-12-15", "2"], ["10778", "5", "3", "1997-12-16", "1"], ["10779", "52", "3", "1997-12-16", "2"], ["10780", "46", "2", "1997-12-16", "1"], ["10781", "87", "2", "1997-12-17", "3"], ["10782", "12", "9", "1997-12-17", "3"], ["10783", "34", "4", "1997-12-18", "2"], ["10784", "49", "4", "1997-12-18", "3"], ["10785", "33", "1", "1997-12-18", "3"], ["10786", "62", "8", "1997-12-19", "1"], ["10787", "41", "2", "1997-12-19", "1"], ["10788", "63", "1", "1997-12-22", "2"], ["10789", "23", "1", "1997-12-22", "2"], ["10790", "31", "6", "1997-12-22", "1"], ["10791", "25", "6", "1997-12-23", "2"], ["10792", "91", "1", "1997-12-23", "3"], ["10793", "4", "3", "1997-12-24", "3"], ["10794", "61", "6", "1997-12-24", "1"], ["10795", "20", "8", "1997-12-24", "2"], ["10796", "35", "3", "1997-12-25", "1"], ["10797", "17", "7", "1997-12-25", "2"], ["10798", "38", "2", "1997-12-26", "1"], ["10799", "39", "9", "1997-12-26", "3"], ["10800", "72", "1", "1997-12-26", "3"], ["10801", "8", "4", "1997-12-29", "2"], ["10802", "73", "4", "1997-12-29", "2"], ["10803", "88", "4", "1997-12-30", "1"], ["10804", "72", "6", "1997-12-30", "2"], ["10805", "77", "2", "1997-12-30", "3"], ["10806", "84", "3", "1997-12-31", "2"], ["10807", "27", "4", "1997-12-31", "1"], ["10808", "60", "2", "1998-01-01", "3"], ["10809", "88", "7", "1998-01-01", "1"], ["10810", "42", "2", "1998-01-01", "3"], ["10811", "47", "8", "1998-01-02", "1"], ["10812", "66", "5", "1998-01-02", "1"], ["10813", "67", "1", "1998-01-05", "1"], ["10814", "84", "3", "1998-01-05", "3"], ["10815", "71", "2", "1998-01-05", "3"], ["10816", "32", "4", "1998-01-06", "2"], ["10817", "39", "3", "1998-01-06", "2"], ["10818", "49", "7", "1998-01-07", "3"], ["10819", "12", "2", "1998-01-07", "3"], ["10820", "65", "3", "1998-01-07", "2"], ["10821", "75", "1", "1998-01-08", "1"], ["10822", "82", "6", "1998-01-08", "3"], ["10823", "46", "5", "1998-01-09", "2"], ["10824", "24", "8", "1998-01-09", "1"], ["10825", "17", "1", "1998-01-09", "1"], ["10826", "7", "6", "1998-01-12", "1"], ["10827", "9", "1", "1998-01-12", "2"], ["10828", "64", "9", "1998-01-13", "1"], ["10829", "38", "9", "1998-01-13", "1"], ["10830", "81", "4", "1998-01-13", "2"], ["10831", "70", "3", "1998-01-14", "2"], ["10832", "41", "2", "1998-01-14", "2"], ["10833", "56", "6", "1998-01-15", "2"], ["10834", "81", "1", "1998-01-15", "3"], ["10835", "1", "1", "1998-01-15", "3"], ["10836", "20", "7", "1998-01-16", "1"], ["10837", "5", "9", "1998-01-16", "3"], ["10838", "47", "3", "1998-01-19", "3"], ["10839", "81", "3", "1998-01-19", "3"], ["10840", "47", "4", "1998-01-19", "2"], ["10841", "76", "5", "1998-01-20", "2"], ["10842", "80", "1", "1998-01-20", "3"], ["10843", "84", "4", "1998-01-21", "2"], ["10844", "59", "8", "1998-01-21", "2"], ["10845", "63", "8", "1998-01-21", "1"], ["10846", "76", "2", "1998-01-22", "3"], ["10847", "71", "4", "1998-01-22", "3"], ["10848", "16", "7", "1998-01-23", "2"], ["10849", "39", "9", "1998-01-23", "2"], ["10850", "84", "1", "1998-01-23", "1"], ["10851", "67", "5", "1998-01-26", "1"], ["10852", "65", "8", "1998-01-26", "1"], ["10853", "6", "9", "1998-01-27", "2"], ["10854", "20", "3", "1998-01-27", "2"], ["10855", "55", "3", "1998-01-27", "1"], ["10856", "3", "3", "1998-01-28", "2"], ["10857", "5", "8", "1998-01-28", "2"], ["10858", "40", "2", "1998-01-29", "1"], ["10859", "25", "1", "1998-01-29", "2"], ["10860", "26", "3", "1998-01-29", "3"], ["10861", "89", "4", "1998-01-30", "2"], ["10862", "44", "8", "1998-01-30", "2"], ["10863", "35", "4", "1998-02-02", "2"], ["10864", "4", "4", "1998-02-02", "2"], ["10865", "63", "2", "1998-02-02", "1"], ["10866", "5", "5", "1998-02-03", "1"], ["10867", "48", "6", "1998-02-03", "1"], ["10868", "62", "7", "1998-02-04", "2"], ["10869", "72", "5", "1998-02-04", "1"], ["10870", "91", "5", "1998-02-04", "3"], ["10871", "9", "9", "1998-02-05", "2"], ["10872", "30", "5", "1998-02-05", "2"], ["10873", "90", "4", "1998-02-06", "1"], ["10874", "30", "5", "1998-02-06", "2"], ["10875", "5", "4", "1998-02-06", "2"], ["10876", "9", "7", "1998-02-09", "3"], ["10877", "67", "1", "1998-02-09", "1"], ["10878", "63", "4", "1998-02-10", "1"], ["10879", "90", "3", "1998-02-10", "3"], ["10880", "24", "7", "1998-02-10", "1"], ["10881", "12", "4", "1998-02-11", "1"], ["10882", "71", "4", "1998-02-11", "3"], ["10883", "48", "8", "1998-02-12", "3"], ["10884", "45", "4", "1998-02-12", "2"], ["10885", "76", "6", "1998-02-12", "3"], ["10886", "34", "1", "1998-02-13", "1"], ["10887", "29", "8", "1998-02-13", "3"], ["10888", "30", "1", "1998-02-16", "2"], ["10889", "65", "9", "1998-02-16", "3"], ["10890", "18", "7", "1998-02-16", "1"], ["10891", "44", "7", "1998-02-17", "2"], ["10892", "50", "4", "1998-02-17", "2"], ["10893", "39", "9", "1998-02-18", "2"], ["10894", "71", "1", "1998-02-18", "1"], ["10895", "20", "3", "1998-02-18", "1"], ["10896", "50", "7", "1998-02-19", "3"], ["10897", "37", "3", "1998-02-19", "2"], ["10898", "54", "4", "1998-02-20", "2"], ["10899", "46", "5", "1998-02-20", "3"], ["10900", "88", "1", "1998-02-20", "2"], ["10901", "35", "4", "1998-02-23", "1"], ["10902", "24", "1", "1998-02-23", "1"], ["10903", "34", "3", "1998-02-24", "3"], ["10904", "89", "3", "1998-02-24", "3"], ["10905", "88", "9", "1998-02-24", "2"], ["10906", "91", "4", "1998-02-25", "3"], ["10907", "74", "6", "1998-02-25", "3"], ["10908", "66", "4", "1998-02-26", "2"], ["10909", "70", "1", "1998-02-26", "2"], ["10910", "90", "1", "1998-02-26", "3"], ["10911", "30", "3", "1998-02-26", "1"], ["10912", "37", "2", "1998-02-26", "2"], ["10913", "62", "4", "1998-02-26", "1"], ["10914", "62", "6", "1998-02-27", "1"], ["10915", "80", "2", "1998-02-27", "2"], ["10916", "64", "1", "1998-02-27", "2"], ["10917", "69", "4", "1998-03-02", "2"], ["10918", "10", "3", "1998-03-02", "3"], ["10919", "47", "2", "1998-03-02", "2"], ["10920", "4", "4", "1998-03-03", "2"], ["10921", "83", "1", "1998-03-03", "1"], ["10922", "34", "5", "1998-03-03", "3"], ["10923", "41", "7", "1998-03-03", "3"], ["10924", "5", "3", "1998-03-04", "2"], ["10925", "34", "3", "1998-03-04", "1"], ["10926", "2", "4", "1998-03-04", "3"], ["10927", "40", "4", "1998-03-05", "1"], ["10928", "29", "1", "1998-03-05", "1"], ["10929", "25", "6", "1998-03-05", "1"], ["10930", "76", "4", "1998-03-06", "3"], ["10931", "68", "4", "1998-03-06", "2"], ["10932", "9", "8", "1998-03-06", "1"], ["10933", "38", "6", "1998-03-06", "3"], ["10934", "44", "3", "1998-03-09", "3"], ["10935", "88", "4", "1998-03-09", "3"], ["10936", "32", "3", "1998-03-09", "2"], ["10937", "12", "7", "1998-03-10", "3"], ["10938", "63", "3", "1998-03-10", "2"], ["10939", "49", "2", "1998-03-10", "2"], ["10940", "9", "8", "1998-03-11", "3"], ["10941", "71", "7", "1998-03-11", "2"], ["10942", "66", "9", "1998-03-11", "3"], ["10943", "11", "4", "1998-03-11", "2"], ["10944", "10", "6", "1998-03-12", "3"], ["10945", "52", "4", "1998-03-12", "1"], ["10946", "83", "1", "1998-03-12", "2"], ["10947", "11", "3", "1998-03-13", "2"], ["10948", "30", "3", "1998-03-13", "3"], ["10949", "10", "2", "1998-03-13", "3"], ["10950", "49", "1", "1998-03-16", "2"], ["10951", "68", "9", "1998-03-16", "2"], ["10952", "1", "1", "1998-03-16", "1"], ["10953", "4", "9", "1998-03-16", "2"], ["10954", "47", "5", "1998-03-17", "1"], ["10955", "24", "8", "1998-03-17", "2"], ["10956", "6", "6", "1998-03-17", "2"], ["10957", "35", "8", "1998-03-18", "3"], ["10958", "54", "7", "1998-03-18", "2"], ["10959", "31", "6", "1998-03-18", "2"], ["10960", "35", "3", "1998-03-19", "1"], ["10961", "62", "8", "1998-03-19", "1"], ["10962", "63", "8", "1998-03-19", "2"], ["10963", "28", "9", "1998-03-19", "3"], ["10964", "74", "3", "1998-03-20", "2"], ["10965", "55", "6", "1998-03-20", "3"], ["10966", "14", "4", "1998-03-20", "1"], ["10967", "79", "2", "1998-03-23", "2"], ["10968", "20", "1", "1998-03-23", "3"], ["10969", "15", "1", "1998-03-23", "2"], ["10970", "8", "9", "1998-03-24", "1"], ["10971", "26", "2", "1998-03-24", "2"], ["10972", "40", "4", "1998-03-24", "2"], ["10973", "40", "6", "1998-03-24", "2"], ["10974", "75", "3", "1998-03-25", "3"], ["10975", "10", "1", "1998-03-25", "3"], ["10976", "35", "1", "1998-03-25", "1"], ["10977", "24", "8", "1998-03-26", "3"], ["10978", "50", "9", "1998-03-26", "2"], ["10979", "20", "8", "1998-03-26", "2"], ["10980", "24", "4", "1998-03-27", "1"], ["10981", "34", "1", "1998-03-27", "2"], ["10982", "10", "2", "1998-03-27", "1"], ["10983", "71", "2", "1998-03-27", "2"], ["10984", "71", "1", "1998-03-30", "3"], ["10985", "37", "2", "1998-03-30", "1"], ["10986", "54", "8", "1998-03-30", "2"], ["10987", "19", "8", "1998-03-31", "1"], ["10988", "65", "3", "1998-03-31", "2"], ["10989", "61", "2", "1998-03-31", "1"], ["10990", "20", "2", "1998-04-01", "3"], ["10991", "63", "1", "1998-04-01", "1"], ["10992", "77", "1", "1998-04-01", "3"], ["10993", "24", "7", "1998-04-01", "3"], ["10994", "83", "2", "1998-04-02", "3"], ["10995", "58", "1", "1998-04-02", "3"], ["10996", "63", "4", "1998-04-02", "2"], ["10997", "46", "8", "1998-04-03", "2"], ["10998", "91", "8", "1998-04-03", "2"], ["10999", "56", "6", "1998-04-03", "2"], ["11000", "65", "2", "1998-04-06", "3"], ["11001", "24", "2", "1998-04-06", "2"], ["11002", "71", "4", "1998-04-06", "1"], ["11003", "78", "3", "1998-04-06", "3"], ["11004", "50", "3", "1998-04-07", "1"], ["11005", "90", "2", "1998-04-07", "1"], ["11006", "32", "3", "1998-04-07", "2"], ["11007", "60", "8", "1998-04-08", "2"], ["11008", "20", "7", "1998-04-08", "3"], ["11009", "30", "2", "1998-04-08", "1"], ["11010", "66", "2", "1998-04-09", "2"], ["11011", "1", "3", "1998-04-09", "1"], ["11012", "25", "1", "1998-04-09", "3"], ["11013", "69", "2", "1998-04-09", "1"], ["11014", "47", "2", "1998-04-10", "3"], ["11015", "70", "2", "1998-04-10", "2"], ["11016", "4", "9", "1998-04-10", "2"], ["11017", "20", "9", "1998-04-13", "2"], ["11018", "48", "4", "1998-04-13", "2"], ["11019", "64", "6", "1998-04-13", "3"], ["11020", "56", "2", "1998-04-14", "2"], ["11021", "63", "3", "1998-04-14", "1"], ["11022", "34", "9", "1998-04-14", "2"], ["11023", "11", "1", "1998-04-14", "2"], ["11024", "19", "4", "1998-04-15", "1"], ["11025", "87", "6", "1998-04-15", "3"], ["11026", "27", "4", "1998-04-15", "1"], ["11027", "10", "1", "1998-04-16", "1"], ["11028", "39", "2", "1998-04-16", "1"], ["11029", "14", "4", "1998-04-16", "1"], ["11030", "71", "7", "1998-04-17", "2"], ["11031", "71", "6", "1998-04-17", "2"], ["11032", "89", "2", "1998-04-17", "3"], ["11033", "68", "7", "1998-04-17", "3"], ["11034", "55", "8", "1998-04-20", "1"], ["11035", "76", "2", "1998-04-20", "2"], ["11036", "17", "8", "1998-04-20", "3"], ["11037", "30", "7", "1998-04-21", "1"], ["11038", "76", "1", "1998-04-21", "2"], ["11039", "47", "1", "1998-04-21", "2"], ["11040", "32", "4", "1998-04-22", "3"], ["11041", "14", "3", "1998-04-22", "2"], ["11042", "15", "2", "1998-04-22", "1"], ["11043", "74", "5", "1998-04-22", "2"], ["11044", "91", "4", "1998-04-23", "1"], ["11045", "10", "6", "1998-04-23", "2"], ["11046", "86", "8", "1998-04-23", "2"], ["11047", "19", "7", "1998-04-24", "3"], ["11048", "10", "7", "1998-04-24", "3"], ["11049", "31", "3", "1998-04-24", "1"], ["11050", "24", "8", "1998-04-27", "2"], ["11051", "41", "7", "1998-04-27", "3"], ["11052", "34", "3", "1998-04-27", "1"], ["11053", "59", "2", "1998-04-27", "2"], ["11054", "12", "8", "1998-04-28", "1"], ["11055", "35", "7", "1998-04-28", "2"], ["11056", "19", "8", "1998-04-28", "2"], ["11057", "53", "3", "1998-04-29", "3"], ["11058", "6", "9", "1998-04-29", "3"], ["11059", "67", "2", "1998-04-29", "2"], ["11060", "27", "2", "1998-04-30", "2"], ["11061", "32", "4", "1998-04-30", "3"], ["11062", "66", "4", "1998-04-30", "2"], ["11063", "37", "3", "1998-04-30", "2"], ["11064", "71", "1", "1998-05-01", "1"], ["11065", "46", "8", "1998-05-01", "1"], ["11066", "89", "7", "1998-05-01", "2"], ["11067", "17", "1", "1998-05-04", "2"], ["11068", "62", "8", "1998-05-04", "2"], ["11069", "80", "1", "1998-05-04", "2"], ["11070", "44", "2", "1998-05-05", "1"], ["11071", "46", "1", "1998-05-05", "1"], ["11072", "20", "4", "1998-05-05", "2"], ["11073", "58", "2", "1998-05-05", "2"], ["11074", "73", "7", "1998-05-06", "2"], ["11075", "68", "8", "1998-05-06", "2"], ["11076", "9", "4", "1998-05-06", "2"], ["11077", "65", "1", "1998-05-06", "2"]], "dataTypes": ["STRING", "STRING", "STRING", "STRING", "STRING"] } } };


</script>
    </script>
</body>

</html>
